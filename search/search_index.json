{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! Infrastructure as Code (IaC) is a well established paradigm and refers to the standard practice of treating infrastructure (network, disk, storage, databases, message queues etc.) in the same way as application code and applying general software engineering practices including source control versioning, testing and more. For example, Terraform and AWS CloudFormation are widely-adopted technologies that use configuration files/templates to represent the infrastructure components. What does it mean in the context of Kubernetes? Over the course of next few (relatively short!) chapters, I will cover how Go developers can use the cdk8s (Cloud Development Kit for Kubernetes) project for defining Kubernetes resources. It's an open-source framework (also part of CNCF) that provides high-level abstractions which can be composed into larger Kubernetes applications. Instead of adopting YAML or other configuration/template driven approach, cdk8s supports multiple programming languages, which means you can work with Kubernetes resources using familiar concepts such as classes, methods, etc. Ultimately, cdk8s generates Kubernetes manifests which you can apply using kubectl - business as usual! At the time of writing, cdk8s supports Go, Typescript, Python and Java Infrastructure IS Code Imagine you have an application that comprises of a Serverless function fronted by an API Gateway along with a NoSQL database as the backend. Instead of defining it in a static way (using JSON, YAML etc.), one can represent these components using standard programming language constructs such as classes, methods, etc. Here is pseudo-code example: DBTable table = new DBTable(\"demo-table\"); table.addPrimaryKey(\"email\", Type.String); Function function = new Function(\"demo-func\"); function.addEnvVars(\"TABLE_NAME\", table.Name()); APIGateway apigw = new APIGateway(); apigw.addFunctionIntegration(function); Notice the (hypothetical) classes DBTable , Function and APIGateway and the way they are used. For e.g. a function can reference the table object and get it's name - all this comes to life during the program runtime and taken care of by the implementation details of the underlying framework/platform. But, you don't have to write pseudo-code for your production infrastructure ... thanks to existing solutions such as cdk8s , AWS CDK , Pulumi , CDK for Terraform ( cdktf ) etc. Almost all these solutions follow a similar approach - write code to define infrastructure, then convert that into configuration, for e.g. Kubernetes manifest (YAML), AWS CloudFormation template , HCL config etc., which can then be applied using standard tooling. While we are on this topic, its hard not to mention the Go programming language and its ubiquitous presence in the cloud services and infrastructure domain. It combines the safety of a compiled language with the speed a interpreted language (like Python ), has a robust standard library and compiles to a single binary. These and many more qualities have led to lots of cloud-native software (IaC, monitoring, observability etc.) written in Go, such as Prometheus , Terraform , Grafana , Jaeger etc. \"In fact, over 75 percent of projects in the Cloud Native Computing Foundation are written in Go.\" Let's get started!!!! Based on this blog series","title":"Welcome!"},{"location":"#welcome","text":"Infrastructure as Code (IaC) is a well established paradigm and refers to the standard practice of treating infrastructure (network, disk, storage, databases, message queues etc.) in the same way as application code and applying general software engineering practices including source control versioning, testing and more. For example, Terraform and AWS CloudFormation are widely-adopted technologies that use configuration files/templates to represent the infrastructure components.","title":"Welcome!"},{"location":"#what-does-it-mean-in-the-context-of-kubernetes","text":"Over the course of next few (relatively short!) chapters, I will cover how Go developers can use the cdk8s (Cloud Development Kit for Kubernetes) project for defining Kubernetes resources. It's an open-source framework (also part of CNCF) that provides high-level abstractions which can be composed into larger Kubernetes applications. Instead of adopting YAML or other configuration/template driven approach, cdk8s supports multiple programming languages, which means you can work with Kubernetes resources using familiar concepts such as classes, methods, etc. Ultimately, cdk8s generates Kubernetes manifests which you can apply using kubectl - business as usual! At the time of writing, cdk8s supports Go, Typescript, Python and Java","title":"What does it mean in the context of Kubernetes?"},{"location":"#infrastructure-is-code","text":"Imagine you have an application that comprises of a Serverless function fronted by an API Gateway along with a NoSQL database as the backend. Instead of defining it in a static way (using JSON, YAML etc.), one can represent these components using standard programming language constructs such as classes, methods, etc. Here is pseudo-code example: DBTable table = new DBTable(\"demo-table\"); table.addPrimaryKey(\"email\", Type.String); Function function = new Function(\"demo-func\"); function.addEnvVars(\"TABLE_NAME\", table.Name()); APIGateway apigw = new APIGateway(); apigw.addFunctionIntegration(function); Notice the (hypothetical) classes DBTable , Function and APIGateway and the way they are used. For e.g. a function can reference the table object and get it's name - all this comes to life during the program runtime and taken care of by the implementation details of the underlying framework/platform. But, you don't have to write pseudo-code for your production infrastructure ... thanks to existing solutions such as cdk8s , AWS CDK , Pulumi , CDK for Terraform ( cdktf ) etc. Almost all these solutions follow a similar approach - write code to define infrastructure, then convert that into configuration, for e.g. Kubernetes manifest (YAML), AWS CloudFormation template , HCL config etc., which can then be applied using standard tooling. While we are on this topic, its hard not to mention the Go programming language and its ubiquitous presence in the cloud services and infrastructure domain. It combines the safety of a compiled language with the speed a interpreted language (like Python ), has a robust standard library and compiles to a single binary. These and many more qualities have led to lots of cloud-native software (IaC, monitoring, observability etc.) written in Go, such as Prometheus , Terraform , Grafana , Jaeger etc. \"In fact, over 75 percent of projects in the Cloud Native Computing Foundation are written in Go.\" Let's get started!!!! Based on this blog series","title":"Infrastructure IS Code"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/","text":"This chapter will start things off and provide a gentle yet hands-on intro to cdk8s . By the end of it, you will be familiar with the key concepts and understand how to use cdk8s Go APIs to define a Kubernetes application, deploy (using kubectl ) and test it out. Before you begin... Make sure you have Go ( v1.16 or above) and cdk8s CLI installed. Also, you need to have access to a Kubernetes cluster. For learning and experimentation I would recommend using a single-node cluster running locally - such as minikube , kind , etc. I generally use minikube , so setting up a cluster is as simple as minikube start To install cdk8s CLI You can choose from the below options: #homebrew brew install cdk8s #npm npm install -g cdk8s-cli #yarn yarn global add cdk8s-cli Alright, lets get started! Although this chapter will provide step-by-step instructions, you can always refer to the complete code on Github cdk8s makes it really easy for you get started and bootstrap your application. You don't need to guess and figure out how to structure your project, setup dependencies etc. since the cdk8s init command does it for you! cdk8s init go-app #output .... Your cdk8s Go project is ready! cat help Prints this message cdk8s synth Synthesize k8s manifests to dist/ cdk8s import Imports k8s API objects to \"imports/k8s\" Deploy: kubectl apply -f dist/ Once completed, you will get a directory structure as such: . \u251c\u2500\u2500 cdk8s.yaml \u251c\u2500\u2500 dist \u2502 \u2514\u2500\u2500 test.k8s.yaml \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 help \u251c\u2500\u2500 imports \u2502 \u2514\u2500\u2500 k8s \u2502 \u251c\u2500\u2500 internal \u2502 \u2502 \u2514\u2500\u2500 types.go \u2502 \u251c\u2500\u2500 jsii \u2502 \u2502 \u251c\u2500\u2500 jsii.go \u2502 \u2502 \u2514\u2500\u2500 k8s-0.0.0.tgz \u2502 \u251c\u2500\u2500 k8s.go \u2502 \u251c\u2500\u2500 k8s.init.go \u2502 \u2514\u2500\u2500 version \u2514\u2500\u2500 main.go Update the generate go.mod file, and replace it with the following - this is to make things simpler for you. Feel free to use the latest version of the modules if needed. module getting-started-with-cdk8s-go go 1.16 require ( github.com/aws/constructs-go/constructs/v10 v10.1.42 github.com/aws/jsii-runtime-go v1.60.1 github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.29 ) You're all set to write some write some Go code! The canonical Kubernetes \"hello world\" is to get a nginx server up and running. The easiest option is to use simply use kubectl run e.g. kubectl run nginx --image=nginx . But, since this is imperative, we switch to a declarative way where we define our desired state (in a yaml file) and ask Kubernetes to figure things out. For e.g. we can write a Deployment manifest and submit it to Kubernetes using kubectl apply -f <name of the yaml file >. apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 1 selector: matchLabels: app: hello-nginx template: metadata: labels: app: hello-nginx spec: containers: - image: nginx name: nginx-container ports: - containerPort: 8080 But we are here to minimise yaml... So, open the main.go file and copy the below Go code. Don't worry, I will walk you through it! package main import ( \"getting-started-with-cdk8s-go/imports/k8s\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type NginxChartProps struct { cdk8s.ChartProps } func NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) selector := &k8s.LabelSelector{MatchLabels: &map[string]*string{\"app\": jsii.String(\"hello-nginx\")}} labels := &k8s.ObjectMeta{Labels: &map[string]*string{\"app\": jsii.String(\"hello-nginx\")}} nginxContainer := &k8s.Container{Name: jsii.String(\"nginx-container\"), Image: jsii.String(\"nginx\"), Ports: &[]*k8s.ContainerPort{{ContainerPort: jsii.Number(80)}}} k8s.NewKubeDeployment(chart, jsii.String(\"deployment\"), &k8s.KubeDeploymentProps{ Spec: &k8s.DeploymentSpec{ Replicas: jsii.Number(1), Selector: selector, Template: &k8s.PodTemplateSpec{ Metadata: labels, Spec: &k8s.PodSpec{ Containers: &[]*k8s.Container{nginxContainer}}}}}) return chart } func main() { app := cdk8s.NewApp(nil) NewNginxChart(app, \"nginx\", nil) app.Synth() } When writing cdk8s based code in any language, you will come across a set of common concepts/terminologies - these include Construct , App and Chart . I will explain these as we walk through the code. Slight detour (code walk-through and concepts) Start with the main function first - we use cdk8s.NewApp to create an App . Well, what exactly in an App ? It's is a construct , and you can think of construct s as higher-level building blocks to represent state . The key thing to note is that these constructs are composable . What that means is that you can define levels of these constructs (each level provides/exposes a different abstraction layer) and combine them to create your desired end state - in this case it happens to be a Kubernetes manifest with objects such as Deployment , but it could be something else. For e.g. an AWS CloudFormation template (if you were to use AWS CDK , not be confused with cdk8s ) Back to the App - so, an App is also a construct. In fact you can think of it as the root in a tree (hierarchy) of constructs. So what else is there in that tree? Look the second line in the main function - NewNginxChart(app, \"getting-started\", nil) - this invokes a function NewNginxChart that returns a cdk8s.Chart which is the next component in the hierarchy. AA cdk8s App can contain multiple charts and each chart can be converted (or in precise cdk8s terminology - synthesized ) into a separate Kubernetes manifest file (you will see this action very soon). Finally, draw your attention to the NewNginxChart function. It has a bunch of things, but notice the call to k8s.NewKubeDeployment function. This is where we actually define a Kubernetes Deployment in code (in the next section, we will also add a Service to the chart.) You can define multiple Kubernetes components in a chart, such a Pod , Service , Ingress , Job etc. - what ever you need for your application to work on Kubernetes. To summarise, here is a visual representation of what I just explained - remember everything is a Construct ( App , Chart etc.) Wait, what about the Kubernetes API dependencies?? If you've spent time working on accessing Kubernetes programmatically, this is an obvious (and great!) question. if you were to deal with k8s object using go, at the minimum you will need Kubernetes client-go , API machinery etc. Guess what, cdk8s has got you covered there too! You actually don't need to pull in these dependencies because cdk8s allows you to treat these Kubernetes API Objects as constructs - remember, everything is s construct! They are automatically imported to your project when you run the cdk8s init command, but you can do it explicitly using cdk8s import as well. The resulting API is available as part of the imports folder (yes, go ahead and check that again!). On the top of main.go , check the package that is imported - its just refers to the imports folder. There is more to cdk8s import though. More to come in the chapters to follow! Alright, lets get back on track... .. and continue with the practical bits. It's time to generate some yaml - you can't eliminate it, but at least you don't have to write it by hand! To do so, simply run: cdk8s synth Once that completes (should be quick!), check the dist directory to check what cdk8s has generated. To make it easier to understand, here is a diagram which has a one-to-one mapping ( notice the labels 1, 2,3, etc.? ) between the the cdk8s code objects/properties to their respective counterparts in yaml e.g. spec.replicas , spec.selector , template.spec etc. You can now use good old kubectl to deploy this to Kubernetes since cdk8s is not going to do that for you, at least not yet ;) kubectl apply -f dist/ kubectl get pods -w Once the Deployment is ready, the Pod should be in Running state. Simply use port-forward to access the nginx container port locally: kubectl port-forward <enter nginx pod name> 8080:80 To access nginx home page, navigate to http://localhost:8080 using your browser You also use a CLI tool e.g. curl localhost:8080 . That's not all! Instead of port forwarding, let's use the standard Kubernetes way of accessing applications by defining a Service resource, which is typically defined like this: apiVersion: v1 kind: Service metadata: name: nginx-service spec: ports: - port: 9090 targetPort: 8080 selector: app: hello-nginx type: LoadBalancer But you know the rule - no yaml writing by hand! So, in the NewNginxChart function in the main.go file, add this piece of code after the part you defined the Deployment : k8s.NewKubeService(chart, jsii.String(\"service\"), &k8s.KubeServiceProps{ Spec: &k8s.ServiceSpec{ Type: jsii.String(\"LoadBalancer\"), Ports: &[]*k8s.ServicePort{{Port: jsii.Number(9090), TargetPort: k8s.IntOrString_FromNumber(jsii.Number(80))}}, Selector: &map[string]*string{\"app\": jsii.String(\"hello-nginx\")}}}) First, delete the existing Deployment - kubectl delete -f dist/ . Then, run cdk8s synth again to create the new manifest in the dist folder. Both the Service and Deployment are in the same file - this is because they are part of the same Chart. How you access the service will depend on the Kubernetes cluster. If you are using a cloud provider, it will likely provision a Load Balancer service native to that cloud e.g. Application Load Balancer in AWS . Please adjust this as per your setup. For minikube , you can simply follow these instructions https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access - \"Services of type LoadBalancer can be exposed via the minikube tunnel command.\" In a terminal, run this command (it runs as a separate process): minikube tunnel In another terminal, delete the existing Deployment and then apply the new manifest: kubectl apply -f dist/ kubectl get pods -w Check the Service : kubectl get svc To access the nginx server, navigate to the external IP (as per the Service ). In the case of minikube, you can simply use localhost:9090 or 127.0.0.0:9090 Remember to use port 9090 since that's the external port we specified in the Service configuration in our code Before wrapping up... .. I want to call out a couple of other useful things in cdk8s . Reference and reuse existing manifests and Helm charts Say you have a Service already defined in a service.yaml file. You can include it in your cdk8s as part of a larger application/chart that you may have. Here is an example: cdk8s.NewInclude(chart, jsii.String(\"existing service\"), &cdk8s.IncludeProps{Url: jsii.String(\"service.yaml\")}) Similarly, you can also include Helm charts. Say you wanted to add bitnami/nginx : cdk8s.NewHelm(chart, jsii.String(\"bitnami nginx helm chart\"), &cdk8s.HelmProps{ Chart: jsii.String(\"bitnami/nginx\"), Values: &map[string]interface{}{\"service.type\": \"ClusterIP\"}}) Well, you do need to have helm installed locally and also add the repo first helm repo add bitnami https://charts.bitnami.com/bitnami Another handy feature is... ... the ability to declare dependencies between any two cdk8s constructs. For instance, in the previous example, we had a Deployment and a Service . You could create a dependency as such: deployment := k8s.NewKubeDeployment(...) service := k8s.NewKubeService(...) deployment.AddDependency(service) Thanks to AddDependency , the resulting manifest will be such that the Service is placed before the Deployment object. Dependency is not limited to individual constructs in a chart. If you have multiple charts as part of your cdk8s app, you can establish dependencies across charts as well. Conclusion Awesome. So you were able to \"code\" your way through trouble and ignore YAML. Hope you enjoyed it! To keep things simple, I demonstrated a Deployment and Service , but you can choose from other Kubernetes components such as Ingress , Job etc. They are all exposed using a similar pattern i.e. NewKube for e.g. NewKubeJob , NewKubeIngress etc. But there is still a lot of boilerplate code involved in defining Kubernetes components. Writing Go code sounds way better than YAML engineering (at least to me), it seems as if we are translating existing YAML into Go structs (and fields). In the next chapter, we will explore how to improve this further.","title":"Getting started with cdk8s"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#before-you-begin","text":"Make sure you have Go ( v1.16 or above) and cdk8s CLI installed. Also, you need to have access to a Kubernetes cluster. For learning and experimentation I would recommend using a single-node cluster running locally - such as minikube , kind , etc. I generally use minikube , so setting up a cluster is as simple as minikube start To install cdk8s CLI You can choose from the below options: #homebrew brew install cdk8s #npm npm install -g cdk8s-cli #yarn yarn global add cdk8s-cli","title":"Before you begin..."},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#alright-lets-get-started","text":"Although this chapter will provide step-by-step instructions, you can always refer to the complete code on Github cdk8s makes it really easy for you get started and bootstrap your application. You don't need to guess and figure out how to structure your project, setup dependencies etc. since the cdk8s init command does it for you! cdk8s init go-app #output .... Your cdk8s Go project is ready! cat help Prints this message cdk8s synth Synthesize k8s manifests to dist/ cdk8s import Imports k8s API objects to \"imports/k8s\" Deploy: kubectl apply -f dist/ Once completed, you will get a directory structure as such: . \u251c\u2500\u2500 cdk8s.yaml \u251c\u2500\u2500 dist \u2502 \u2514\u2500\u2500 test.k8s.yaml \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 help \u251c\u2500\u2500 imports \u2502 \u2514\u2500\u2500 k8s \u2502 \u251c\u2500\u2500 internal \u2502 \u2502 \u2514\u2500\u2500 types.go \u2502 \u251c\u2500\u2500 jsii \u2502 \u2502 \u251c\u2500\u2500 jsii.go \u2502 \u2502 \u2514\u2500\u2500 k8s-0.0.0.tgz \u2502 \u251c\u2500\u2500 k8s.go \u2502 \u251c\u2500\u2500 k8s.init.go \u2502 \u2514\u2500\u2500 version \u2514\u2500\u2500 main.go Update the generate go.mod file, and replace it with the following - this is to make things simpler for you. Feel free to use the latest version of the modules if needed. module getting-started-with-cdk8s-go go 1.16 require ( github.com/aws/constructs-go/constructs/v10 v10.1.42 github.com/aws/jsii-runtime-go v1.60.1 github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.29 )","title":"Alright, lets get started!"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#youre-all-set-to-write-some-write-some-go-code","text":"The canonical Kubernetes \"hello world\" is to get a nginx server up and running. The easiest option is to use simply use kubectl run e.g. kubectl run nginx --image=nginx . But, since this is imperative, we switch to a declarative way where we define our desired state (in a yaml file) and ask Kubernetes to figure things out. For e.g. we can write a Deployment manifest and submit it to Kubernetes using kubectl apply -f <name of the yaml file >. apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 1 selector: matchLabels: app: hello-nginx template: metadata: labels: app: hello-nginx spec: containers: - image: nginx name: nginx-container ports: - containerPort: 8080","title":"You're all set to write some write some Go code!"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#but-we-are-here-to-minimise-yaml","text":"So, open the main.go file and copy the below Go code. Don't worry, I will walk you through it! package main import ( \"getting-started-with-cdk8s-go/imports/k8s\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type NginxChartProps struct { cdk8s.ChartProps } func NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) selector := &k8s.LabelSelector{MatchLabels: &map[string]*string{\"app\": jsii.String(\"hello-nginx\")}} labels := &k8s.ObjectMeta{Labels: &map[string]*string{\"app\": jsii.String(\"hello-nginx\")}} nginxContainer := &k8s.Container{Name: jsii.String(\"nginx-container\"), Image: jsii.String(\"nginx\"), Ports: &[]*k8s.ContainerPort{{ContainerPort: jsii.Number(80)}}} k8s.NewKubeDeployment(chart, jsii.String(\"deployment\"), &k8s.KubeDeploymentProps{ Spec: &k8s.DeploymentSpec{ Replicas: jsii.Number(1), Selector: selector, Template: &k8s.PodTemplateSpec{ Metadata: labels, Spec: &k8s.PodSpec{ Containers: &[]*k8s.Container{nginxContainer}}}}}) return chart } func main() { app := cdk8s.NewApp(nil) NewNginxChart(app, \"nginx\", nil) app.Synth() } When writing cdk8s based code in any language, you will come across a set of common concepts/terminologies - these include Construct , App and Chart . I will explain these as we walk through the code.","title":"But we are here to minimise yaml..."},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#slight-detour-code-walk-through-and-concepts","text":"Start with the main function first - we use cdk8s.NewApp to create an App . Well, what exactly in an App ? It's is a construct , and you can think of construct s as higher-level building blocks to represent state . The key thing to note is that these constructs are composable . What that means is that you can define levels of these constructs (each level provides/exposes a different abstraction layer) and combine them to create your desired end state - in this case it happens to be a Kubernetes manifest with objects such as Deployment , but it could be something else. For e.g. an AWS CloudFormation template (if you were to use AWS CDK , not be confused with cdk8s ) Back to the App - so, an App is also a construct. In fact you can think of it as the root in a tree (hierarchy) of constructs. So what else is there in that tree? Look the second line in the main function - NewNginxChart(app, \"getting-started\", nil) - this invokes a function NewNginxChart that returns a cdk8s.Chart which is the next component in the hierarchy. AA cdk8s App can contain multiple charts and each chart can be converted (or in precise cdk8s terminology - synthesized ) into a separate Kubernetes manifest file (you will see this action very soon). Finally, draw your attention to the NewNginxChart function. It has a bunch of things, but notice the call to k8s.NewKubeDeployment function. This is where we actually define a Kubernetes Deployment in code (in the next section, we will also add a Service to the chart.) You can define multiple Kubernetes components in a chart, such a Pod , Service , Ingress , Job etc. - what ever you need for your application to work on Kubernetes. To summarise, here is a visual representation of what I just explained - remember everything is a Construct ( App , Chart etc.) Wait, what about the Kubernetes API dependencies?? If you've spent time working on accessing Kubernetes programmatically, this is an obvious (and great!) question. if you were to deal with k8s object using go, at the minimum you will need Kubernetes client-go , API machinery etc. Guess what, cdk8s has got you covered there too! You actually don't need to pull in these dependencies because cdk8s allows you to treat these Kubernetes API Objects as constructs - remember, everything is s construct! They are automatically imported to your project when you run the cdk8s init command, but you can do it explicitly using cdk8s import as well. The resulting API is available as part of the imports folder (yes, go ahead and check that again!). On the top of main.go , check the package that is imported - its just refers to the imports folder. There is more to cdk8s import though. More to come in the chapters to follow!","title":"Slight detour (code walk-through and concepts)"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#alright-lets-get-back-on-track","text":".. and continue with the practical bits. It's time to generate some yaml - you can't eliminate it, but at least you don't have to write it by hand! To do so, simply run: cdk8s synth Once that completes (should be quick!), check the dist directory to check what cdk8s has generated. To make it easier to understand, here is a diagram which has a one-to-one mapping ( notice the labels 1, 2,3, etc.? ) between the the cdk8s code objects/properties to their respective counterparts in yaml e.g. spec.replicas , spec.selector , template.spec etc. You can now use good old kubectl to deploy this to Kubernetes since cdk8s is not going to do that for you, at least not yet ;) kubectl apply -f dist/ kubectl get pods -w Once the Deployment is ready, the Pod should be in Running state. Simply use port-forward to access the nginx container port locally: kubectl port-forward <enter nginx pod name> 8080:80 To access nginx home page, navigate to http://localhost:8080 using your browser You also use a CLI tool e.g. curl localhost:8080 .","title":"Alright, lets get back on track..."},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#thats-not-all","text":"Instead of port forwarding, let's use the standard Kubernetes way of accessing applications by defining a Service resource, which is typically defined like this: apiVersion: v1 kind: Service metadata: name: nginx-service spec: ports: - port: 9090 targetPort: 8080 selector: app: hello-nginx type: LoadBalancer But you know the rule - no yaml writing by hand! So, in the NewNginxChart function in the main.go file, add this piece of code after the part you defined the Deployment : k8s.NewKubeService(chart, jsii.String(\"service\"), &k8s.KubeServiceProps{ Spec: &k8s.ServiceSpec{ Type: jsii.String(\"LoadBalancer\"), Ports: &[]*k8s.ServicePort{{Port: jsii.Number(9090), TargetPort: k8s.IntOrString_FromNumber(jsii.Number(80))}}, Selector: &map[string]*string{\"app\": jsii.String(\"hello-nginx\")}}}) First, delete the existing Deployment - kubectl delete -f dist/ . Then, run cdk8s synth again to create the new manifest in the dist folder. Both the Service and Deployment are in the same file - this is because they are part of the same Chart. How you access the service will depend on the Kubernetes cluster. If you are using a cloud provider, it will likely provision a Load Balancer service native to that cloud e.g. Application Load Balancer in AWS . Please adjust this as per your setup. For minikube , you can simply follow these instructions https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access - \"Services of type LoadBalancer can be exposed via the minikube tunnel command.\" In a terminal, run this command (it runs as a separate process): minikube tunnel In another terminal, delete the existing Deployment and then apply the new manifest: kubectl apply -f dist/ kubectl get pods -w Check the Service : kubectl get svc To access the nginx server, navigate to the external IP (as per the Service ). In the case of minikube, you can simply use localhost:9090 or 127.0.0.0:9090 Remember to use port 9090 since that's the external port we specified in the Service configuration in our code","title":"That's not all!"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#before-wrapping-up","text":".. I want to call out a couple of other useful things in cdk8s . Reference and reuse existing manifests and Helm charts Say you have a Service already defined in a service.yaml file. You can include it in your cdk8s as part of a larger application/chart that you may have. Here is an example: cdk8s.NewInclude(chart, jsii.String(\"existing service\"), &cdk8s.IncludeProps{Url: jsii.String(\"service.yaml\")}) Similarly, you can also include Helm charts. Say you wanted to add bitnami/nginx : cdk8s.NewHelm(chart, jsii.String(\"bitnami nginx helm chart\"), &cdk8s.HelmProps{ Chart: jsii.String(\"bitnami/nginx\"), Values: &map[string]interface{}{\"service.type\": \"ClusterIP\"}}) Well, you do need to have helm installed locally and also add the repo first helm repo add bitnami https://charts.bitnami.com/bitnami Another handy feature is... ... the ability to declare dependencies between any two cdk8s constructs. For instance, in the previous example, we had a Deployment and a Service . You could create a dependency as such: deployment := k8s.NewKubeDeployment(...) service := k8s.NewKubeService(...) deployment.AddDependency(service) Thanks to AddDependency , the resulting manifest will be such that the Service is placed before the Deployment object. Dependency is not limited to individual constructs in a chart. If you have multiple charts as part of your cdk8s app, you can establish dependencies across charts as well.","title":"Before wrapping up..."},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#conclusion","text":"Awesome. So you were able to \"code\" your way through trouble and ignore YAML. Hope you enjoyed it! To keep things simple, I demonstrated a Deployment and Service , but you can choose from other Kubernetes components such as Ingress , Job etc. They are all exposed using a similar pattern i.e. NewKube for e.g. NewKubeJob , NewKubeIngress etc. But there is still a lot of boilerplate code involved in defining Kubernetes components. Writing Go code sounds way better than YAML engineering (at least to me), it seems as if we are translating existing YAML into Go structs (and fields). In the next chapter, we will explore how to improve this further.","title":"Conclusion"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/","text":"The previous chapter covered how to get started with cdk8s (Cloud Development Kit for Kubernetes), that is an an open-source framework (part of CNCF) using which you can define your Kubernetes applications using regular programming languages (instead of yaml ). You were able to setup a simple nginx Deployment and accessed it via a Service - all this was done using Go, which was then converted to yaml (using cdk8s synth ) and submitted to the cluster using kubectl . This was a good start. However, since the core cdk8s library is pretty low-level (for a good reason!) the code involved lot of boilerplate (you can refer to the code here ). cdk8s-plus leverages building blocks from cdk8s core library, thereby helping reduce verbosity and complexity by providing higher level abstractions/APIs for all Kubernetes objects such as Deployment s, Service s, etc. In this blog, we will see cdk8s-plus in action and even deploy Wordpress on Kubernetes with it! Let's start by revamping the Nginx deployment.. To witness how cdk8s-plus works, it's best to look at the code. It is available on Github . I will walk you through the code as we go along. func NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) dep := cdk8splus22.NewDeployment(chart, jsii.String(\"deployment\"), &cdk8splus22.DeploymentProps{Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(\"nginx-deployment-cdk8s-plus\")}}) dep.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"nginx-container\"), Image: jsii.String(\"nginx\"), Port: jsii.Number(80)}) dep.ExposeViaService(&cdk8splus22.DeploymentExposeViaServiceOptions{ Name: jsii.String(\"nginx-container-service\"), ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER, Ports: &[]*cdk8splus22.ServicePort{{Port: jsii.Number(9090), TargetPort: jsii.Number(80)}}}) return chart } We start by creating a Deployment , then add a container and finally expose it using a Service . This is quite intuitive and user-friendly. The container details could have been provided via DeploymentProps but using AddContainer seemed more natural (at least to me). To generate Kubernetes manifest, simply run cdk8s synth . This will generate a yaml in the dist folder. Here is an example (some of the names, labels etc. will be different in your case): apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment-cdk8s-plus spec: minReadySeconds: 0 progressDeadlineSeconds: 600 replicas: 1 selector: matchLabels: cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate template: metadata: labels: cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e spec: automountServiceAccountToken: true containers: - image: nginx imagePullPolicy: Always name: nginx-container ports: - containerPort: 80 securityContext: privileged: false readOnlyRootFilesystem: false runAsNonRoot: false dnsPolicy: ClusterFirst securityContext: fsGroupChangePolicy: Always runAsNonRoot: false setHostnameAsFQDN: false --- apiVersion: v1 kind: Service metadata: name: nginx-container-service spec: externalIPs: [] ports: - port: 9090 targetPort: 80 selector: cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e type: LoadBalancer Both the Deployment and Service are present in the same manifest, since they were declared in the same Chart . It's worth noting that there was no need to specify any Pod label selectors, template labels (in Deployment code) or Service selector. cdk8s-plus took care of it by auto-generating cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e , which was used in s pec.selector.matchLabels and spec.template.metadata.labels , along with the Service selector in nginx-container-service A note on dependencies go.mod lists all the modules: require ( github.com/aws/constructs-go/constructs/v10 v10.1.42 github.com/aws/jsii-runtime-go v1.61.0 github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.31 github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22/v2 v2.0.0-rc.23 ) Note that we are using cdk8splus22 . The reason for this naming convention is because each cdk8s-plus library is separately vended to target a specific Kubernetes version - the 22 at the end signifies that this dependency will work with Kubernetes 1.22 I would recommend reading the FAQs to get further clarity To test this locally... ... you can use minikube , kind , etc. git clone https://github.com/abhirockzz/cdk8s-for-go-developers cd part2-cdk8s-plus-in-action/nginx-example # make sure cluster is running minikube start # create the resources kubectl apply -f dist/ kubectl get pods -w Once Pod is running, check the Service : kubectl get svc In a terminal, run this command (it runs as a separate process): minikube tunnel To access the nginx server, navigate to the external IP (as per the Service ). In the case of minikube, you can simply use localhost:9090 or 127.0.0.0:9090 How about a Wordpress installation on Kubernetes? I like this example - it's not overly complex but realistic enough because it has multiple moving parts that includes a combination of stateless, stateful components, different kinds of services etc. This chapter is not a deep dive into Wordpress and loosely inspired by this article in the Kubernetes documentation , which I assume folks might be familiar with. The main function will give you a sense of what lies ahead: func main() { app := cdk8s.NewApp(nil) mySQLChart := NewMySQLChart(app, \"mysql\", nil) wordpressChart := NewWordpressChart(app, \"wordpress\", nil) wordpressChart.AddDependency(mySQLChart) app.Synth() } So far, we have dealt with a single chart. Our Wordpress cdk8s application has two separate charts - one for MySQL database and the other one for Wordpress. This will result in two different manifests being created as a result of cdk8s synth process. Let's look the MySQL chart first some code has been omitted for brevity We start by defining a Kubernetes Secret to store MySQL password (with NewSecret ): func NewMySQLChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart { //.... secretName := \"mysql-pass\" password := \"Password123\" mysqlSecret := cdk8splus22.NewSecret(chart, jsii.String(\"mysql-secret\"), &cdk8splus22.SecretProps{ Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)}}) secretKey := \"password\" mysqlSecret.AddStringData(jsii.String(secretKey), jsii.String(password)) MySQL password has been declared in the code - not a best practice by any means, just for demo. Do not do this in production! Then we create the Deployment and provide container details. Notice how the Secret has been added as an environment variable to the container: - First we got an EnvValue using EnvValue_FromSecretValue - That was added to the container using Env#AddVariable dep := cdk8splus22.NewDeployment(chart, jsii.String(\"mysql-deployment-cdk8splus\"), &cdk8splus22.DeploymentProps{}) containerImage := \"mysql\" mysqlContainer := dep.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"mysql-container\"), Image: jsii.String(containerImage), Port: jsii.Number(3306), }) envValFromSecret := cdk8splus22.EnvValue_FromSecretValue(&cdk8splus22.SecretValue{Key: jsii.String(secretKey), Secret: mysqlSecret}, &cdk8splus22.EnvValueFromSecretOptions{Optional: jsii.Bool(false)}) mySQLPasswordEnvName := \"MYSQL_ROOT_PASSWORD\" mysqlContainer.Env().AddVariable(jsii.String(mySQLPasswordEnvName), envValFromSecret) For durable storage, we create a PersistentVolumeClaim , use that to define a Volume and mount in onto the container at the path /var/lib/mysql . mysqlPVC := cdk8splus22.NewPersistentVolumeClaim(chart, jsii.String(\"mysql-pvc\"), &cdk8splus22.PersistentVolumeClaimProps{ AccessModes: &[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE}, Storage: cdk8s.Size_Gibibytes(jsii.Number(2))}) mysqlVolumeName := \"mysql-persistent-storage\" mysqlVolume := cdk8splus22.Volume_FromPersistentVolumeClaim(chart, jsii.String(\"mysql-vol-pvc\"), mysqlPVC, &cdk8splus22.PersistentVolumeClaimVolumeOptions{Name: jsii.String(mysqlVolumeName)}) mySQLVolumeMountPath := \"/var/lib/mysql\" mysqlContainer.Mount(jsii.String(mySQLVolumeMountPath), mysqlVolume, &cdk8splus22.MountOptions{}) Finally, we create a Service : mySQLServiceName := \"mysql-service\" clusterIPNone := \"None\" cdk8splus22.NewService(chart, jsii.String(\"mysql-service\"), &cdk8splus22.ServiceProps{ Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(mySQLServiceName)}, Selector: dep, ClusterIP: jsii.String(clusterIPNone), Ports: &[]*cdk8splus22.ServicePort{{Port: jsii.Number(3306)}}, }) Unlike previous example, we create a Service explicitly and then refer to Deployment object in the service selector. Wordpress Chart - Except for minor differences, it's the same as the MySQL chart with Wordpress specific configuration obviously. So I won't repeat it here - feel free to explore the code . The moment of truth is here! Rinse and repeat - cdk8s synth to create the manifest and apply it with kubectl : cd part2-cdk8s-plus-in-action/wordpress #create manifests cdk8s synth #apply them kubectl apply -f dist/ #output - you will see something similar to: secret/mysql-pass created deployment.apps/mysql-mysql-deployment-cdk8splus-c83762d9 created persistentvolumeclaim/mysql-mysql-pvc-c8799bba created service/mysql-service created deployment.apps/wordpress-wordpress-deployment-cdk8splus-c8252da7 created service/wordpress-service created persistentvolumeclaim/wordpress-wordpress-pvc-c8334a29 created In a different terminal run (if not already running): minikube tunnel Use your browser to navigate to http://localhost:80. You should see the familiar Wordpress installation screen. Go ahead, finish the installation and log into your Wordpress instance. Feel free to experiment. Maybe try deleting the MySQL deployment and re-creating it. Thanks to the PersistentVolume , MySQL data should be recovered and wordpress will continue to work. Conclusion Awesome! In this chapter you saw the expressiveness of cdk8s-plus . We started off with a compact and less verbose version of the Nginx deployment and ended up with a full-fledged Wordpress instance - all using Go.","title":"cdk8s-plus in action!"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#lets-start-by-revamping-the-nginx-deployment","text":"To witness how cdk8s-plus works, it's best to look at the code. It is available on Github . I will walk you through the code as we go along. func NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) dep := cdk8splus22.NewDeployment(chart, jsii.String(\"deployment\"), &cdk8splus22.DeploymentProps{Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(\"nginx-deployment-cdk8s-plus\")}}) dep.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"nginx-container\"), Image: jsii.String(\"nginx\"), Port: jsii.Number(80)}) dep.ExposeViaService(&cdk8splus22.DeploymentExposeViaServiceOptions{ Name: jsii.String(\"nginx-container-service\"), ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER, Ports: &[]*cdk8splus22.ServicePort{{Port: jsii.Number(9090), TargetPort: jsii.Number(80)}}}) return chart } We start by creating a Deployment , then add a container and finally expose it using a Service . This is quite intuitive and user-friendly. The container details could have been provided via DeploymentProps but using AddContainer seemed more natural (at least to me). To generate Kubernetes manifest, simply run cdk8s synth . This will generate a yaml in the dist folder. Here is an example (some of the names, labels etc. will be different in your case): apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment-cdk8s-plus spec: minReadySeconds: 0 progressDeadlineSeconds: 600 replicas: 1 selector: matchLabels: cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate template: metadata: labels: cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e spec: automountServiceAccountToken: true containers: - image: nginx imagePullPolicy: Always name: nginx-container ports: - containerPort: 80 securityContext: privileged: false readOnlyRootFilesystem: false runAsNonRoot: false dnsPolicy: ClusterFirst securityContext: fsGroupChangePolicy: Always runAsNonRoot: false setHostnameAsFQDN: false --- apiVersion: v1 kind: Service metadata: name: nginx-container-service spec: externalIPs: [] ports: - port: 9090 targetPort: 80 selector: cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e type: LoadBalancer Both the Deployment and Service are present in the same manifest, since they were declared in the same Chart . It's worth noting that there was no need to specify any Pod label selectors, template labels (in Deployment code) or Service selector. cdk8s-plus took care of it by auto-generating cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e , which was used in s pec.selector.matchLabels and spec.template.metadata.labels , along with the Service selector in nginx-container-service A note on dependencies go.mod lists all the modules: require ( github.com/aws/constructs-go/constructs/v10 v10.1.42 github.com/aws/jsii-runtime-go v1.61.0 github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.31 github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22/v2 v2.0.0-rc.23 ) Note that we are using cdk8splus22 . The reason for this naming convention is because each cdk8s-plus library is separately vended to target a specific Kubernetes version - the 22 at the end signifies that this dependency will work with Kubernetes 1.22 I would recommend reading the FAQs to get further clarity To test this locally... ... you can use minikube , kind , etc. git clone https://github.com/abhirockzz/cdk8s-for-go-developers cd part2-cdk8s-plus-in-action/nginx-example # make sure cluster is running minikube start # create the resources kubectl apply -f dist/ kubectl get pods -w Once Pod is running, check the Service : kubectl get svc In a terminal, run this command (it runs as a separate process): minikube tunnel To access the nginx server, navigate to the external IP (as per the Service ). In the case of minikube, you can simply use localhost:9090 or 127.0.0.0:9090","title":"Let's start by revamping the Nginx deployment.."},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#how-about-a-wordpress-installation-on-kubernetes","text":"I like this example - it's not overly complex but realistic enough because it has multiple moving parts that includes a combination of stateless, stateful components, different kinds of services etc. This chapter is not a deep dive into Wordpress and loosely inspired by this article in the Kubernetes documentation , which I assume folks might be familiar with. The main function will give you a sense of what lies ahead: func main() { app := cdk8s.NewApp(nil) mySQLChart := NewMySQLChart(app, \"mysql\", nil) wordpressChart := NewWordpressChart(app, \"wordpress\", nil) wordpressChart.AddDependency(mySQLChart) app.Synth() } So far, we have dealt with a single chart. Our Wordpress cdk8s application has two separate charts - one for MySQL database and the other one for Wordpress. This will result in two different manifests being created as a result of cdk8s synth process. Let's look the MySQL chart first some code has been omitted for brevity We start by defining a Kubernetes Secret to store MySQL password (with NewSecret ): func NewMySQLChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart { //.... secretName := \"mysql-pass\" password := \"Password123\" mysqlSecret := cdk8splus22.NewSecret(chart, jsii.String(\"mysql-secret\"), &cdk8splus22.SecretProps{ Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)}}) secretKey := \"password\" mysqlSecret.AddStringData(jsii.String(secretKey), jsii.String(password)) MySQL password has been declared in the code - not a best practice by any means, just for demo. Do not do this in production! Then we create the Deployment and provide container details. Notice how the Secret has been added as an environment variable to the container: - First we got an EnvValue using EnvValue_FromSecretValue - That was added to the container using Env#AddVariable dep := cdk8splus22.NewDeployment(chart, jsii.String(\"mysql-deployment-cdk8splus\"), &cdk8splus22.DeploymentProps{}) containerImage := \"mysql\" mysqlContainer := dep.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"mysql-container\"), Image: jsii.String(containerImage), Port: jsii.Number(3306), }) envValFromSecret := cdk8splus22.EnvValue_FromSecretValue(&cdk8splus22.SecretValue{Key: jsii.String(secretKey), Secret: mysqlSecret}, &cdk8splus22.EnvValueFromSecretOptions{Optional: jsii.Bool(false)}) mySQLPasswordEnvName := \"MYSQL_ROOT_PASSWORD\" mysqlContainer.Env().AddVariable(jsii.String(mySQLPasswordEnvName), envValFromSecret) For durable storage, we create a PersistentVolumeClaim , use that to define a Volume and mount in onto the container at the path /var/lib/mysql . mysqlPVC := cdk8splus22.NewPersistentVolumeClaim(chart, jsii.String(\"mysql-pvc\"), &cdk8splus22.PersistentVolumeClaimProps{ AccessModes: &[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE}, Storage: cdk8s.Size_Gibibytes(jsii.Number(2))}) mysqlVolumeName := \"mysql-persistent-storage\" mysqlVolume := cdk8splus22.Volume_FromPersistentVolumeClaim(chart, jsii.String(\"mysql-vol-pvc\"), mysqlPVC, &cdk8splus22.PersistentVolumeClaimVolumeOptions{Name: jsii.String(mysqlVolumeName)}) mySQLVolumeMountPath := \"/var/lib/mysql\" mysqlContainer.Mount(jsii.String(mySQLVolumeMountPath), mysqlVolume, &cdk8splus22.MountOptions{}) Finally, we create a Service : mySQLServiceName := \"mysql-service\" clusterIPNone := \"None\" cdk8splus22.NewService(chart, jsii.String(\"mysql-service\"), &cdk8splus22.ServiceProps{ Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(mySQLServiceName)}, Selector: dep, ClusterIP: jsii.String(clusterIPNone), Ports: &[]*cdk8splus22.ServicePort{{Port: jsii.Number(3306)}}, }) Unlike previous example, we create a Service explicitly and then refer to Deployment object in the service selector. Wordpress Chart - Except for minor differences, it's the same as the MySQL chart with Wordpress specific configuration obviously. So I won't repeat it here - feel free to explore the code .","title":"How about a Wordpress installation on Kubernetes?"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#the-moment-of-truth-is-here","text":"Rinse and repeat - cdk8s synth to create the manifest and apply it with kubectl : cd part2-cdk8s-plus-in-action/wordpress #create manifests cdk8s synth #apply them kubectl apply -f dist/ #output - you will see something similar to: secret/mysql-pass created deployment.apps/mysql-mysql-deployment-cdk8splus-c83762d9 created persistentvolumeclaim/mysql-mysql-pvc-c8799bba created service/mysql-service created deployment.apps/wordpress-wordpress-deployment-cdk8splus-c8252da7 created service/wordpress-service created persistentvolumeclaim/wordpress-wordpress-pvc-c8334a29 created In a different terminal run (if not already running): minikube tunnel Use your browser to navigate to http://localhost:80. You should see the familiar Wordpress installation screen. Go ahead, finish the installation and log into your Wordpress instance. Feel free to experiment. Maybe try deleting the MySQL deployment and re-creating it. Thanks to the PersistentVolume , MySQL data should be recovered and wordpress will continue to work.","title":"The moment of truth is here!"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#conclusion","text":"Awesome! In this chapter you saw the expressiveness of cdk8s-plus . We started off with a compact and less verbose version of the Nginx deployment and ended up with a full-fledged Wordpress instance - all using Go.","title":"Conclusion"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/","text":"cdk8s (Cloud Development Kit for Kubernetes) is an an open-source framework (part of CNCF) using which you can define your Kubernetes applications with regular programming languages (instead of yaml ). One of the previous chapter covered the getting started experience and using cdk8s-plus library to further improve upon the core cdk8s library features. We are going to continue and push cdk8s even further. This chapter will demonstrate how you can use Kubernetes Custom Resource Definitions with cdk8s . We will start off with a simple Nginx example and then you will use the combination of Strimzi project CRDs along with Go and cdk8s to define and deploy a Kafka cluster on Kubernetes! I am assuming that you've have some knowledge of Kubernetes Custom Resource Definitions and have probably even used a few in the form of Operators . If not, that's ok! The Kubernetes documentation covers it quite well. You can always refer to it, come back here and follow along! cdk8s lets you use Kubernetes API objects directly in your code, without having to import individual Go client packages, all thanks to cdk8s import . (also mentioned in the \"Wait, what about the Kubernetes API dependencies??\" section the previous chapter. But you can also use it for Custom Resource Definitions! Let's see this in action. Before you begin... Make sure you have Go ( v1.16 or above) and cdk8s CLI installed. Also, you need to have access to a Kubernetes cluster. For learning and experimentation I would recommend using a single-node cluster running locally - such as minikube , kind , etc. I generally use minikube , so setting up a cluster is as simple as minikube start To install cdk8s CLI You can choose from the below options: #homebrew brew install cdk8s #npm npm install -g cdk8s-cli #yarn yarn global add cdk8s-cli Alright, lets get started... Although this chapter will provide step-by-step instructions, you can always refer to the complete code on Github cdk8s makes it really easy for you get started and bootstrap your application. You don't need to guess and figure out how to structure your project, setup dependencies etc. since the cdk8s init command does it for you! cdk8s init go-app #output .... Your cdk8s Go project is ready! cat help Prints this message cdk8s synth Synthesize k8s manifests to dist/ cdk8s import Imports k8s API objects to \"imports/k8s\" Deploy: kubectl apply -f dist/ Update the generate go.mod file, and replace it with the following - this is to make things simpler for you. Feel free to use the latest version of the modules if needed. module cdk8s-crd go 1.16 require ( github.com/aws/constructs-go/constructs/v10 v10.1.42 github.com/aws/jsii-runtime-go v1.61.0 github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.34 ) To start with, let's work with a really (really!) simple Custom Resource Definition I am going to use a sample CRD from the Kubernetes example . To be honest, it doesn't really do anything. But, since we're just getting started, this should suffice! First, install/register the CRD resource itself: kubectl apply -f https://raw.githubusercontent.com/kubernetes/sample-controller/master/artifacts/examples/crd.yaml Confirm whether the CRD was installed: kubectl get crd # output NAME CREATED AT foos.samplecontroller.k8s.io 2022-07-08T09:28:46Z kubectl get foos.samplecontroller.k8s.io #output (as expected) No resources found in default namespace. So, we just installed a CRD with the name foos.samplecontroller.k8s.io and type Foo . Its possible to create an instance of this using yaml ... but... We are here to write Go code! To do that, first import the CRD as an API using cdk8s - this will automatically create the corresponding Go API representations ( struct s etc.): cdk8s import https://raw.githubusercontent.com/kubernetes/sample-controller/master/artifacts/examples/crd.yaml Check the imports directory, an additional folder should have been created. imports/ \u2514\u2500\u2500 samplecontrollerk8sio \u251c\u2500\u2500 internal \u2502 \u2514\u2500\u2500 types.go \u251c\u2500\u2500 jsii \u2502 \u251c\u2500\u2500 jsii.go \u2502 \u2514\u2500\u2500 samplecontrollerk8sio-0.0.0.tgz \u251c\u2500\u2500 samplecontrollerk8sio.go \u251c\u2500\u2500 samplecontrollerk8sio.init.go \u2514\u2500\u2500 version We can now use the CRD just like any other Kubernetes resource/API (like Deployment ) and import it in the cdk8s Go code. Create a new file called foo.go and copy the following code: package main import ( \"cdk8s-crd/imports/samplecontrollerk8sio\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type FooChartProps struct { cdk8s.ChartProps } func NewFooChart(scope constructs.Construct, id string, props *FooChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) samplecontrollerk8sio.NewFoo(chart, jsii.String(\"foo1\"), &samplecontrollerk8sio.FooProps{Spec: &samplecontrollerk8sio.FooSpec{DeploymentName: jsii.String(\"foo1-dep\"), Replicas: jsii.Number(2)}}) return chart } See how we created an instance of samplecontrollerk8sio.Foo : - Imported the autogenerated CRD API from the cdk8s-crd/imports/samplecontrollerk8sio package, - Used the NewFoo function and provided the metadata via FooProps Replace the contents of main.go with the following: package main import ( \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s.ChartProps } func main() { app := cdk8s.NewApp(nil) NewFooChart(app, \"FooApp\", nil) app.Synth() } All we is include the Chart that we defined just now (in foo.go ) and include it in the cdk8s App . To create the Foo resource... Run cdk8s synth - this will result in a manifest in the dist folder: apiVersion: samplecontroller.k8s.io/v1alpha1 kind: Foo spec: deploymentName: foo1-dep replicas: 2 metadata: name: fooapp-foo1-c80094ac To create it in Kubernetes: kubectl apply -f dist You can confirm by running : kubectl get foo kubectl get foos.samplecontroller.k8s.io To introspect further, you can use the name of the created resource e.g. kubectl describe foo/fooapp-foo1-c80094ac Alright, now that you've seen a simple example, we can move on to something slightly more advanced. Setup Kafka on Kubernetes using Strimzi, cdk8s and Go Strimzi is an open-source CNCF project and one of my personal favourites! If you don't know about Strimzi, that's ok. It's enough to understand that it provides a way to run an Apache Kafka on Kubernetes with the help of Custom Resource Definitions and corresponding Operators for components such as Kafka cluster, Kafka Connect topic, users, Kafka Mirror etc. Here is a high-level diagram of how the different Strimzi components interact. Since a Strimzi deep-dive is out of scope, I would recommend that you refer its (excellent!) documentation for details. As before, we need to first install the CRD itself (you can also refer to the Strimzi Quickstart ) kubectl create namespace kafka kubectl create -f 'https://strimzi.io/install/latest?namespace=kafka' -n kafka # wait for the Operator Pod to start up (Running) kubectl get pod -n kafka --watch You can also check the Operator logs using kubectl logs deployment/strimzi-cluster-operator -n kafka -f Each supported Kafka component (cluster, connect, user etc.) has a corresponding Custom Resource Definition - for the purposes of this chapter, we will just use the Kafka cluster and topic CRDs. Let's import them as an API: cdk8s import https://raw.githubusercontent.com/strimzi/strimzi-kafka-operator/main/install/cluster-operator/040-Crd-kafka.yaml cdk8s import kafkatopic:=https://raw.githubusercontent.com/strimzi/strimzi-kafka-operator/main/install/cluster-operator/043-Crd-kafkatopic.yaml Note that I've prepended kafkatopic to the module name for Kafka topic CRD Check the imports folder - you should see two additional folders named kafkastrimziio and kafkatopic_kafkastrimziio . Time for some Go code, again Create a kafka_strimzi.go file and copy the code from Github repo : Or you can also simply do this: curl -o kafka.go https://raw.githubusercontent.com/abhirockzz/cdk8s-for-go-developers/master/part3-crd/kafka_strimzi.go I will walk you through the important parts of the code here. Start with the NewKafkaChart function that creates a new Chart . func NewKafkaChart(scope constructs.Construct, id string, props *KafkaChartProps) cdk8s.Chart { //.... ommitted for brevity chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) See how the Kafka cluster is defined using kafkastrimziio.KafkaProps struct (for a deep-dive into each of these components you can refer to Strimzi documentation ). We specify the Kafka version, number of nodes/replicas (we will stick to a single node replica) how to expose the cluster etc. //.... &kafkastrimziio.KafkaProps{ Spec: &kafkastrimziio.KafkaSpec{ Kafka: &kafkastrimziio.KafkaSpecKafka{ Version: jsii.String(\"3.2.0\"), Replicas: jsii.Number(1), Listeners: &[]*kafkastrimziio.KafkaSpecKafkaListeners{ { Name: jsii.String(\"plain\"), Port: jsii.Number(9092), Type: kafkastrimziio.KafkaSpecKafkaListenersType_INTERNAL, Tls: jsii.Bool(false), }, }, //.... Then we add required config for the Kafka cluster (in-line with the fact that we have a single node cluster only) as well as storage (ephemeral storage will work for this example). //... Config: map[string]interface{}{ \"offsets.topic.replication.factor\": 1, \"transaction.state.log.replication.factor\": 1, \"transaction.state.log.min.isr\": 1, \"default.replication.factor\": 1, \"min.insync.replicas\": 1, \"inter.broker.protocol.version\": \"3.2\", }, Storage: &kafkastrimziio.KafkaSpecKafkaStorage{ Type: kafkastrimziio.KafkaSpecKafkaStorageType_EPHEMERAL, }, //... Finally, we configure Zookeeper as well as the Entity operator that handles Kafka topics (as well as users, although we don't use it here) //... Zookeeper: &kafkastrimziio.KafkaSpecZookeeper{ Replicas: jsii.Number(1), Storage: &kafkastrimziio.KafkaSpecZookeeperStorage{ Type: kafkastrimziio.KafkaSpecZookeeperStorageType_EPHEMERAL, }, }, EntityOperator: &kafkastrimziio.KafkaSpecEntityOperator{ TopicOperator: &kafkastrimziio.KafkaSpecEntityOperatorTopicOperator{}, }}}) //... To wire it up, update the main.go file: func main() { app := cdk8s.NewApp(nil) //NewFooChart(app, \"FooApp\", nil) NewKafkaChart(app, \"KafkaApp\", nil) app.Synth() } To create a Kafka cluster using the CRD... Follow the the usual workflow: # generate manifest (check it in dist folder) cdk8s synth # apply it (note the kafka namespace) kubectl apply -f dist/ -n kafka Wait for the resources to be created: KAFKA_CRD_INSTANCE_NAME=$(kubectl get kafka -n kafka -o=jsonpath='{.items[0].metadata.name}') kubectl wait kafka/$KAFKA_CRD_INSTANCE_NAME --for=condition=Ready --timeout=300s -n kafka Once all the Kafka cluster resources are created, you should see the following message - kafka.kafka.strimzi.io/<name of your Kafka CRD instance> condition met . The Kafka cluster is now ready and we can test it using the good old Kafka CLI based producer and consumer (instructions in Strimzi quickstart). BOOSTRAP_SERVER=$(kubectl get kafka -n kafka -o=jsonpath='{.items[0].metadata.name}')-kafka-bootstrap kubectl -n kafka run kafka-producer -ti --image=quay.io/strimzi/kafka:0.29.0-kafka-3.2.0 --rm=true --restart=Never -- bin/kafka-console-producer.sh --bootstrap-server $BOOSTRAP_SERVER:9092 --topic test-topic kubectl -n kafka run kafka-consumer -ti --image=quay.io/strimzi/kafka:0.29.0-kafka-3.2.0 --rm=true --restart=Never -- bin/kafka-console-consumer.sh --bootstrap-server $BOOSTRAP_SERVER:9092 --topic test-topic --from-beginning That's all for now! Time to wrap up... You learnt how to combine Kubernetes Custom Resource definition with cdk8s . This is really powerful and means that you can continue to use code (in this case, written in Go) to define built-in Kubernetes resources (like Deployment s etc.) as well as Custom resources! Did you like what you tried? Well, you can continue learning! Couple of suggestions: You can try updating the existing code to add a Deployment resource that refers to a Kafka client app (you have to write it and package it as a Docker container first) and can access the Kafka cluster you created. Explore how you can get the connectivity parameters.. The Kafka cluster we created was configured to have Internal access only. Explore options to expose it externally (refer to Strimzi documentation) and update the code to implement that (should be a small change). Which Kubernetes objects will be affected by it?","title":"Using Custom Resource Definitions with cdk8s"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#before-you-begin","text":"Make sure you have Go ( v1.16 or above) and cdk8s CLI installed. Also, you need to have access to a Kubernetes cluster. For learning and experimentation I would recommend using a single-node cluster running locally - such as minikube , kind , etc. I generally use minikube , so setting up a cluster is as simple as minikube start To install cdk8s CLI You can choose from the below options: #homebrew brew install cdk8s #npm npm install -g cdk8s-cli #yarn yarn global add cdk8s-cli","title":"Before you begin..."},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#alright-lets-get-started","text":"Although this chapter will provide step-by-step instructions, you can always refer to the complete code on Github cdk8s makes it really easy for you get started and bootstrap your application. You don't need to guess and figure out how to structure your project, setup dependencies etc. since the cdk8s init command does it for you! cdk8s init go-app #output .... Your cdk8s Go project is ready! cat help Prints this message cdk8s synth Synthesize k8s manifests to dist/ cdk8s import Imports k8s API objects to \"imports/k8s\" Deploy: kubectl apply -f dist/ Update the generate go.mod file, and replace it with the following - this is to make things simpler for you. Feel free to use the latest version of the modules if needed. module cdk8s-crd go 1.16 require ( github.com/aws/constructs-go/constructs/v10 v10.1.42 github.com/aws/jsii-runtime-go v1.61.0 github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.34 ) To start with, let's work with a really (really!) simple Custom Resource Definition I am going to use a sample CRD from the Kubernetes example . To be honest, it doesn't really do anything. But, since we're just getting started, this should suffice! First, install/register the CRD resource itself: kubectl apply -f https://raw.githubusercontent.com/kubernetes/sample-controller/master/artifacts/examples/crd.yaml Confirm whether the CRD was installed: kubectl get crd # output NAME CREATED AT foos.samplecontroller.k8s.io 2022-07-08T09:28:46Z kubectl get foos.samplecontroller.k8s.io #output (as expected) No resources found in default namespace. So, we just installed a CRD with the name foos.samplecontroller.k8s.io and type Foo . Its possible to create an instance of this using yaml ... but... We are here to write Go code! To do that, first import the CRD as an API using cdk8s - this will automatically create the corresponding Go API representations ( struct s etc.): cdk8s import https://raw.githubusercontent.com/kubernetes/sample-controller/master/artifacts/examples/crd.yaml Check the imports directory, an additional folder should have been created. imports/ \u2514\u2500\u2500 samplecontrollerk8sio \u251c\u2500\u2500 internal \u2502 \u2514\u2500\u2500 types.go \u251c\u2500\u2500 jsii \u2502 \u251c\u2500\u2500 jsii.go \u2502 \u2514\u2500\u2500 samplecontrollerk8sio-0.0.0.tgz \u251c\u2500\u2500 samplecontrollerk8sio.go \u251c\u2500\u2500 samplecontrollerk8sio.init.go \u2514\u2500\u2500 version We can now use the CRD just like any other Kubernetes resource/API (like Deployment ) and import it in the cdk8s Go code. Create a new file called foo.go and copy the following code: package main import ( \"cdk8s-crd/imports/samplecontrollerk8sio\" \"github.com/aws/constructs-go/constructs/v10\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type FooChartProps struct { cdk8s.ChartProps } func NewFooChart(scope constructs.Construct, id string, props *FooChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) samplecontrollerk8sio.NewFoo(chart, jsii.String(\"foo1\"), &samplecontrollerk8sio.FooProps{Spec: &samplecontrollerk8sio.FooSpec{DeploymentName: jsii.String(\"foo1-dep\"), Replicas: jsii.Number(2)}}) return chart } See how we created an instance of samplecontrollerk8sio.Foo : - Imported the autogenerated CRD API from the cdk8s-crd/imports/samplecontrollerk8sio package, - Used the NewFoo function and provided the metadata via FooProps Replace the contents of main.go with the following: package main import ( \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\" ) type MyChartProps struct { cdk8s.ChartProps } func main() { app := cdk8s.NewApp(nil) NewFooChart(app, \"FooApp\", nil) app.Synth() } All we is include the Chart that we defined just now (in foo.go ) and include it in the cdk8s App . To create the Foo resource... Run cdk8s synth - this will result in a manifest in the dist folder: apiVersion: samplecontroller.k8s.io/v1alpha1 kind: Foo spec: deploymentName: foo1-dep replicas: 2 metadata: name: fooapp-foo1-c80094ac To create it in Kubernetes: kubectl apply -f dist You can confirm by running : kubectl get foo kubectl get foos.samplecontroller.k8s.io To introspect further, you can use the name of the created resource e.g. kubectl describe foo/fooapp-foo1-c80094ac Alright, now that you've seen a simple example, we can move on to something slightly more advanced.","title":"Alright, lets get started..."},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#setup-kafka-on-kubernetes-using-strimzi-cdk8s-and-go","text":"Strimzi is an open-source CNCF project and one of my personal favourites! If you don't know about Strimzi, that's ok. It's enough to understand that it provides a way to run an Apache Kafka on Kubernetes with the help of Custom Resource Definitions and corresponding Operators for components such as Kafka cluster, Kafka Connect topic, users, Kafka Mirror etc. Here is a high-level diagram of how the different Strimzi components interact. Since a Strimzi deep-dive is out of scope, I would recommend that you refer its (excellent!) documentation for details. As before, we need to first install the CRD itself (you can also refer to the Strimzi Quickstart ) kubectl create namespace kafka kubectl create -f 'https://strimzi.io/install/latest?namespace=kafka' -n kafka # wait for the Operator Pod to start up (Running) kubectl get pod -n kafka --watch You can also check the Operator logs using kubectl logs deployment/strimzi-cluster-operator -n kafka -f Each supported Kafka component (cluster, connect, user etc.) has a corresponding Custom Resource Definition - for the purposes of this chapter, we will just use the Kafka cluster and topic CRDs. Let's import them as an API: cdk8s import https://raw.githubusercontent.com/strimzi/strimzi-kafka-operator/main/install/cluster-operator/040-Crd-kafka.yaml cdk8s import kafkatopic:=https://raw.githubusercontent.com/strimzi/strimzi-kafka-operator/main/install/cluster-operator/043-Crd-kafkatopic.yaml Note that I've prepended kafkatopic to the module name for Kafka topic CRD Check the imports folder - you should see two additional folders named kafkastrimziio and kafkatopic_kafkastrimziio . Time for some Go code, again Create a kafka_strimzi.go file and copy the code from Github repo : Or you can also simply do this: curl -o kafka.go https://raw.githubusercontent.com/abhirockzz/cdk8s-for-go-developers/master/part3-crd/kafka_strimzi.go I will walk you through the important parts of the code here. Start with the NewKafkaChart function that creates a new Chart . func NewKafkaChart(scope constructs.Construct, id string, props *KafkaChartProps) cdk8s.Chart { //.... ommitted for brevity chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) See how the Kafka cluster is defined using kafkastrimziio.KafkaProps struct (for a deep-dive into each of these components you can refer to Strimzi documentation ). We specify the Kafka version, number of nodes/replicas (we will stick to a single node replica) how to expose the cluster etc. //.... &kafkastrimziio.KafkaProps{ Spec: &kafkastrimziio.KafkaSpec{ Kafka: &kafkastrimziio.KafkaSpecKafka{ Version: jsii.String(\"3.2.0\"), Replicas: jsii.Number(1), Listeners: &[]*kafkastrimziio.KafkaSpecKafkaListeners{ { Name: jsii.String(\"plain\"), Port: jsii.Number(9092), Type: kafkastrimziio.KafkaSpecKafkaListenersType_INTERNAL, Tls: jsii.Bool(false), }, }, //.... Then we add required config for the Kafka cluster (in-line with the fact that we have a single node cluster only) as well as storage (ephemeral storage will work for this example). //... Config: map[string]interface{}{ \"offsets.topic.replication.factor\": 1, \"transaction.state.log.replication.factor\": 1, \"transaction.state.log.min.isr\": 1, \"default.replication.factor\": 1, \"min.insync.replicas\": 1, \"inter.broker.protocol.version\": \"3.2\", }, Storage: &kafkastrimziio.KafkaSpecKafkaStorage{ Type: kafkastrimziio.KafkaSpecKafkaStorageType_EPHEMERAL, }, //... Finally, we configure Zookeeper as well as the Entity operator that handles Kafka topics (as well as users, although we don't use it here) //... Zookeeper: &kafkastrimziio.KafkaSpecZookeeper{ Replicas: jsii.Number(1), Storage: &kafkastrimziio.KafkaSpecZookeeperStorage{ Type: kafkastrimziio.KafkaSpecZookeeperStorageType_EPHEMERAL, }, }, EntityOperator: &kafkastrimziio.KafkaSpecEntityOperator{ TopicOperator: &kafkastrimziio.KafkaSpecEntityOperatorTopicOperator{}, }}}) //... To wire it up, update the main.go file: func main() { app := cdk8s.NewApp(nil) //NewFooChart(app, \"FooApp\", nil) NewKafkaChart(app, \"KafkaApp\", nil) app.Synth() } To create a Kafka cluster using the CRD... Follow the the usual workflow: # generate manifest (check it in dist folder) cdk8s synth # apply it (note the kafka namespace) kubectl apply -f dist/ -n kafka Wait for the resources to be created: KAFKA_CRD_INSTANCE_NAME=$(kubectl get kafka -n kafka -o=jsonpath='{.items[0].metadata.name}') kubectl wait kafka/$KAFKA_CRD_INSTANCE_NAME --for=condition=Ready --timeout=300s -n kafka Once all the Kafka cluster resources are created, you should see the following message - kafka.kafka.strimzi.io/<name of your Kafka CRD instance> condition met . The Kafka cluster is now ready and we can test it using the good old Kafka CLI based producer and consumer (instructions in Strimzi quickstart). BOOSTRAP_SERVER=$(kubectl get kafka -n kafka -o=jsonpath='{.items[0].metadata.name}')-kafka-bootstrap kubectl -n kafka run kafka-producer -ti --image=quay.io/strimzi/kafka:0.29.0-kafka-3.2.0 --rm=true --restart=Never -- bin/kafka-console-producer.sh --bootstrap-server $BOOSTRAP_SERVER:9092 --topic test-topic kubectl -n kafka run kafka-consumer -ti --image=quay.io/strimzi/kafka:0.29.0-kafka-3.2.0 --rm=true --restart=Never -- bin/kafka-console-consumer.sh --bootstrap-server $BOOSTRAP_SERVER:9092 --topic test-topic --from-beginning That's all for now!","title":"Setup Kafka on Kubernetes using Strimzi, cdk8s and Go"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#time-to-wrap-up","text":"You learnt how to combine Kubernetes Custom Resource definition with cdk8s . This is really powerful and means that you can continue to use code (in this case, written in Go) to define built-in Kubernetes resources (like Deployment s etc.) as well as Custom resources! Did you like what you tried? Well, you can continue learning! Couple of suggestions: You can try updating the existing code to add a Deployment resource that refers to a Kafka client app (you have to write it and package it as a Docker container first) and can access the Kafka cluster you created. Explore how you can get the connectivity parameters.. The Kafka cluster we created was configured to have Internal access only. Explore options to expose it externally (refer to Strimzi documentation) and update the code to implement that (should be a small change). Which Kubernetes objects will be affected by it?","title":"Time to wrap up..."},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/","text":"Constructs are the fundamental building block of cdk8s (Cloud Development Kit for Kubernetes) - an open-source framework (part of CNCF) with which you can define your Kubernetes applications using regular programming languages (instead of yaml ). In Getting started with cdk8s , you saw how to use the core cdk8s library. You can also use the cdk8s-plus library (as covered in an earlier chapter) to reduce the amount of boilerplate code you need to write. With cdk8s-plus , creating a Kubernetes Deployment , specifying it's container (and other properties) and exposing it via a Service is three function calls away. For example, to setup and access Nginx , you simply need this: //... deployment := cdk8splus22.NewDeployment(chart, jsii.String(\"deployment\"), &cdk8splus22.DeploymentProps{Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(\"nginx-deployment-cdk8s-plus\")}}) deployment.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"nginx-container\"), Image: jsii.String(\"nginx\"), Port: jsii.Number(80)}) deployment.ExposeViaService(&cdk8splus22.DeploymentExposeViaServiceOptions{ Name: jsii.String(\"nginx-container-service\"), ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER, Ports: &[]*cdk8splus22.ServicePort{{Port: jsii.Number(9090), TargetPort: jsii.Number(80)}}}) //... But things can get even better! Instead of writing the same logic over and over, you can package it in the form of a reusable component that can be invoked just like other built-in cdk8s functions (e.g. NewDeployment , NewService etc.). Although it might not sound as useful for the simple application(s), this approach is invaluable for a large project, team or organisation who want to scale their engineering efforts. In fact, there is already a pool of ready-to-use components available at constructs.dev . These include constructs contributed by the community, AWS and others as well, across multiple programming languages. To better understand how this might look in practice ... let's look at the code. I will continue to use Wordpress as an example, like I did in the previous chapter. Here is a code snippet that shows how everything is wired together (with implementation walk-through in the next section): You can refer to the complete code on Github //... func NewMyChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart { //.... NewWordpressStack(chart, jsii.String(\"wordpress-stack\"), &WordpressProps{//....) return chart } func main() { app := cdk8s.NewApp(nil) NewMyChart(app, \"wordpress-custom-stack\", nil) app.Synth() } NewWordpressStack gives us a construct that represents an entire Wordpress installation (single line of code!) We simply configure it as per our requirements (with WordpressProps ) Include this as part of a cdk8s.Chart which is then included in the cdk8s.App (as with any other cdk8s application) There is lot of flexibility in terms of how you want to build a custom construct, depending on your requirements. But, at its very core, the basic concept is to define a way to create a new construct.Construct . You would want to provide a way to add metadata to further configure/refine your Construct - typically, thats done through properties ( cdk8s.ChartProps ). First we define WordpressProps - this encapsulates/externalises the attributes of the Wordpress installation. Since this is just an example, I have provided limited attributes such as MySQL/Wordpress Docker images, MySQL password, and required storage. type WordpressProps struct { MySQLImage *string MySQLPassword *string MySQLStorage *float64 WordpressImage *string WordpressStorage *float64 } Then we have a function that will allow other charts/constructs to instantiate Wordpress. This is where the entire implementation resides. func NewWordpressStack(scope constructs.Construct, id *string, props *WordpressProps) constructs.Construct { ... } The props *WordpressProps parameter allows other constructs to influence the Wordpress stack creation e.g. you can define how much storage you need, maybe use a different Docker image for Wordpress/MySQL. The actual code for this function is similar to the one you saw here (with required adjustments), so there is no point repeating it here. I will simply highlight the important bits - specifically the ones that use the props to configure the required components. This sample construct used cdk8splus22 library. The reason for this naming convention is because each cdk8s-plus library is separately vended to target a specific Kubernetes version - the 22 at the end signifies that this dependency will work with Kubernetes 1.22 . You can use the library corresponding to your Kubernetes version and refer to the FAQs for more info. We use the MySQL password from props and use that to create the Secret . //... password := props.MySQLPassword mysqlSecret := cdk8splus22.NewSecret(wordpressConstruct, jsii.String(\"mysql-secret\"), &cdk8splus22.SecretProps{ Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)}}) secretKey := \"password\" mysqlSecret.AddStringData(jsii.String(secretKey), password) //... The container images for MySQL and Wordpress are referenced via their respective Deployment s: //... containerImage := props.MySQLImage mysqlContainer := dep.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"mysql-container\"), Image: containerImage, Port: jsii.Number(3306), }) //... wordpressContainer := wordPressDeployment.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"wordpress-container\"), Image: props.WordpressImage, Port: jsii.Number(80), }) We also use the passed in storage as well - this is used to configure the PersistentVolumeClaim request. ... mysqlPVC := cdk8splus22.NewPersistentVolumeClaim(wordpressConstruct, jsii.String(\"mysql-pvc\"), &cdk8splus22.PersistentVolumeClaimProps{ AccessModes: &[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE}, Storage: cdk8s.Size_Gibibytes(props.MySQLStorage)}) ... wordpressPVC := cdk8splus22.NewPersistentVolumeClaim(wordpressConstruct, jsii.String(\"wordpress-pvc\"), &cdk8splus22.PersistentVolumeClaimProps{ AccessModes: &[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE}, Storage: cdk8s.Size_Gibibytes(props.WordpressStorage)}) Finally, we call NewWordpressStack from another cdk8s.Chart and pass in the attributes we want to configure. func NewMyChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) NewWordpressStack(chart, jsii.String(\"wordpress-stack\"), &WordpressProps{ MySQLImage: jsii.String(\"mysql\"), MySQLPassword: jsii.String(\"Password123\"), MySQLStorage: jsii.Number(3), WordpressImage: jsii.String(\"wordpress:4.8-apache\"), WordpressStorage: jsii.Number(2)}) return chart } Use this to install Wordpress To test it locally... ... you can use minikube , kind , etc. # make sure cluster is running minikube start git clone https://github.com/abhirockzz/cdk8s-for-go-developers cd part4-custom-construct Create manifest and inspect all the resources (see dist directory): cdk8s synth To deploy them: kubectl apply -f dist/ # output (might differ in your case) secret/mysql-pass created deployment.apps/mysql-mysql-deployment-cdk8splus-c83762d9 created persistentvolumeclaim/mysql-mysql-pvc-c8799bba created service/mysql-service created deployment.apps/wordpress-wordpress-deployment-cdk8splus-c8252da7 created service/wordpress-service created persistentvolumeclaim/wordpress-wordpress-pvc-c8334a29 created Check the Kubernetes Service (called wordpress-service ) which exposes the wordpress Deployment . kubectl get svc wordpress-service If you're using minikube , in a different terminal run (if not already running): minikube tunnel Use your browser to navigate to http://localhost:80. You should see the familiar Wordpress installation screen. Go ahead, finish the installation and log into your Wordpress instance. Feel free to experiment with it. Conclusion cdk8s is a powerful tool itself but it also provides you the ability to extend and build other abstraction on top of it. You saw how to write a custom construct in Go and used it deploy Wordpress on Kubernetes. This can be further used as a foundation for other re-usable components.","title":"Extend cdk8s with custom Constructs"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/#to-better-understand-how-this-might-look-in-practice","text":"... let's look at the code. I will continue to use Wordpress as an example, like I did in the previous chapter. Here is a code snippet that shows how everything is wired together (with implementation walk-through in the next section): You can refer to the complete code on Github //... func NewMyChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart { //.... NewWordpressStack(chart, jsii.String(\"wordpress-stack\"), &WordpressProps{//....) return chart } func main() { app := cdk8s.NewApp(nil) NewMyChart(app, \"wordpress-custom-stack\", nil) app.Synth() } NewWordpressStack gives us a construct that represents an entire Wordpress installation (single line of code!) We simply configure it as per our requirements (with WordpressProps ) Include this as part of a cdk8s.Chart which is then included in the cdk8s.App (as with any other cdk8s application) There is lot of flexibility in terms of how you want to build a custom construct, depending on your requirements. But, at its very core, the basic concept is to define a way to create a new construct.Construct . You would want to provide a way to add metadata to further configure/refine your Construct - typically, thats done through properties ( cdk8s.ChartProps ). First we define WordpressProps - this encapsulates/externalises the attributes of the Wordpress installation. Since this is just an example, I have provided limited attributes such as MySQL/Wordpress Docker images, MySQL password, and required storage. type WordpressProps struct { MySQLImage *string MySQLPassword *string MySQLStorage *float64 WordpressImage *string WordpressStorage *float64 } Then we have a function that will allow other charts/constructs to instantiate Wordpress. This is where the entire implementation resides. func NewWordpressStack(scope constructs.Construct, id *string, props *WordpressProps) constructs.Construct { ... } The props *WordpressProps parameter allows other constructs to influence the Wordpress stack creation e.g. you can define how much storage you need, maybe use a different Docker image for Wordpress/MySQL. The actual code for this function is similar to the one you saw here (with required adjustments), so there is no point repeating it here. I will simply highlight the important bits - specifically the ones that use the props to configure the required components. This sample construct used cdk8splus22 library. The reason for this naming convention is because each cdk8s-plus library is separately vended to target a specific Kubernetes version - the 22 at the end signifies that this dependency will work with Kubernetes 1.22 . You can use the library corresponding to your Kubernetes version and refer to the FAQs for more info. We use the MySQL password from props and use that to create the Secret . //... password := props.MySQLPassword mysqlSecret := cdk8splus22.NewSecret(wordpressConstruct, jsii.String(\"mysql-secret\"), &cdk8splus22.SecretProps{ Metadata: &cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)}}) secretKey := \"password\" mysqlSecret.AddStringData(jsii.String(secretKey), password) //... The container images for MySQL and Wordpress are referenced via their respective Deployment s: //... containerImage := props.MySQLImage mysqlContainer := dep.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"mysql-container\"), Image: containerImage, Port: jsii.Number(3306), }) //... wordpressContainer := wordPressDeployment.AddContainer(&cdk8splus22.ContainerProps{ Name: jsii.String(\"wordpress-container\"), Image: props.WordpressImage, Port: jsii.Number(80), }) We also use the passed in storage as well - this is used to configure the PersistentVolumeClaim request. ... mysqlPVC := cdk8splus22.NewPersistentVolumeClaim(wordpressConstruct, jsii.String(\"mysql-pvc\"), &cdk8splus22.PersistentVolumeClaimProps{ AccessModes: &[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE}, Storage: cdk8s.Size_Gibibytes(props.MySQLStorage)}) ... wordpressPVC := cdk8splus22.NewPersistentVolumeClaim(wordpressConstruct, jsii.String(\"wordpress-pvc\"), &cdk8splus22.PersistentVolumeClaimProps{ AccessModes: &[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE}, Storage: cdk8s.Size_Gibibytes(props.WordpressStorage)}) Finally, we call NewWordpressStack from another cdk8s.Chart and pass in the attributes we want to configure. func NewMyChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart { var cprops cdk8s.ChartProps if props != nil { cprops = props.ChartProps } chart := cdk8s.NewChart(scope, jsii.String(id), &cprops) NewWordpressStack(chart, jsii.String(\"wordpress-stack\"), &WordpressProps{ MySQLImage: jsii.String(\"mysql\"), MySQLPassword: jsii.String(\"Password123\"), MySQLStorage: jsii.Number(3), WordpressImage: jsii.String(\"wordpress:4.8-apache\"), WordpressStorage: jsii.Number(2)}) return chart }","title":"To better understand how this might look in practice"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/#use-this-to-install-wordpress","text":"To test it locally... ... you can use minikube , kind , etc. # make sure cluster is running minikube start git clone https://github.com/abhirockzz/cdk8s-for-go-developers cd part4-custom-construct Create manifest and inspect all the resources (see dist directory): cdk8s synth To deploy them: kubectl apply -f dist/ # output (might differ in your case) secret/mysql-pass created deployment.apps/mysql-mysql-deployment-cdk8splus-c83762d9 created persistentvolumeclaim/mysql-mysql-pvc-c8799bba created service/mysql-service created deployment.apps/wordpress-wordpress-deployment-cdk8splus-c8252da7 created service/wordpress-service created persistentvolumeclaim/wordpress-wordpress-pvc-c8334a29 created Check the Kubernetes Service (called wordpress-service ) which exposes the wordpress Deployment . kubectl get svc wordpress-service If you're using minikube , in a different terminal run (if not already running): minikube tunnel Use your browser to navigate to http://localhost:80. You should see the familiar Wordpress installation screen. Go ahead, finish the installation and log into your Wordpress instance. Feel free to experiment with it.","title":"Use this to install Wordpress"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/#conclusion","text":"cdk8s is a powerful tool itself but it also provides you the ability to extend and build other abstraction on top of it. You saw how to write a custom construct in Go and used it deploy Wordpress on Kubernetes. This can be further used as a foundation for other re-usable components.","title":"Conclusion"},{"location":"Part%205%3A%20Coming%20soon/","text":"coming soon","title":"coming soon"},{"location":"Part%205%3A%20Coming%20soon/#coming-soon","text":"","title":"coming soon"},{"location":"Part%206%3A%20Coming%20soon/","text":"coming soon","title":"coming soon"},{"location":"Part%206%3A%20Coming%20soon/#coming-soon","text":"","title":"coming soon"}]}
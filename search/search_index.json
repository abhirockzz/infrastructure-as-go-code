{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Infrastructure as Code (IaC) is a well established paradigm and refers to the standard practice of treating infrastructure (network, disk, storage, databases, message queues etc.) in the same way as application code and applying general software engineering practices including source control versioning, testing and more. For example, Terraform and AWS CloudFormation are widely-adopted technologies that use configuration files/templates to represent the infrastructure components.</p>"},{"location":"#what-does-it-mean-in-the-context-of-kubernetes","title":"What does it mean in the context of Kubernetes?","text":"<p>Over the course of next few (relatively short!) chapters, I will cover how Go developers can use the cdk8s (Cloud Development Kit for Kubernetes) project for defining Kubernetes resources. It's an open-source framework (also part of CNCF)  that provides high-level abstractions which can be composed into larger Kubernetes applications. Instead of adopting YAML or other configuration/template driven approach, <code>cdk8s</code> supports multiple programming languages, which means you can work with Kubernetes resources using familiar concepts such as classes, methods, etc. Ultimately, <code>cdk8s</code> generates Kubernetes manifests which you can <code>apply</code> using <code>kubectl</code> - business as usual!</p> <p>At the time of writing, <code>cdk8s</code> supports Go, Typescript, Python and Java</p>"},{"location":"#infrastructure-is-code","title":"Infrastructure IS Code","text":"<p>Imagine you have an application that comprises of a Serverless function fronted by an API Gateway along with a NoSQL database as the backend. Instead of defining it in a static way (using JSON, YAML etc.), one can represent these components using standard programming language constructs such as classes, methods, etc. Here is pseudo-code example:</p> <pre><code>DBTable table = new DBTable(\"demo-table\");\ntable.addPrimaryKey(\"email\", Type.String);\n\nFunction function = new Function(\"demo-func\");\nfunction.addEnvVars(\"TABLE_NAME\", table.Name());\n\nAPIGateway apigw = new APIGateway();\napigw.addFunctionIntegration(function);\n</code></pre> <p>Notice the (hypothetical) classes <code>DBTable</code>, <code>Function</code> and <code>APIGateway</code> and the way they are used. For e.g. a <code>function</code> can reference the <code>table</code> object and get it's name - all this comes to life during the program runtime and taken care of by the implementation details of the underlying framework/platform.</p> <p>But, you don't have to write pseudo-code for your production infrastructure</p> <p>... thanks to existing solutions such as cdk8s, AWS CDK, Pulumi, CDK for Terraform (<code>cdktf</code>) etc. Almost all these solutions follow a similar approach - write code to define infrastructure, then convert that into configuration, for e.g. Kubernetes manifest (YAML), AWS CloudFormation template, HCL config etc., which can then be applied using standard tooling.</p> <p>While we are on this topic, its hard not to mention the Go programming language and its ubiquitous presence in the cloud services and infrastructure domain. It combines the safety of a compiled language with the speed a interpreted language (like <code>Python</code>), has a robust standard library and compiles to a single binary. These and many more qualities have led to lots of cloud-native software (IaC, monitoring, observability etc.) written in Go, such as Prometheus, Terraform, Grafana, Jaeger etc. </p> <p>\"In fact, over 75 percent of projects in the Cloud Native Computing Foundation are written in Go.\"</p> <p>Let's get started!!!!</p> <p>Based on this blog series</p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/","title":"Getting started with cdk8s","text":"<p>This chapter will start things off and provide a gentle yet hands-on intro to <code>cdk8s</code>. By the end of it, you will be familiar with the key concepts and understand how to use <code>cdk8s</code> Go APIs to define a Kubernetes application, deploy (using <code>kubectl</code>) and test it out.</p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#before-you-begin","title":"Before you begin...","text":"<p>Make sure you have <code>Go</code> (v1.16 or above) and cdk8s CLI installed. Also, you need to have access to a Kubernetes cluster. For learning and experimentation I would recommend using a single-node cluster running locally - such as minikube, kind, etc.</p> <p>I generally use <code>minikube</code>, so setting up a cluster is as simple as <code>minikube start</code></p> <p>To install cdk8s CLI</p> <p>You can choose from the below options:</p> <pre><code>#homebrew\nbrew install cdk8s\n\n#npm\nnpm install -g cdk8s-cli\n\n#yarn\nyarn global add cdk8s-cli\n</code></pre>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#alright-lets-get-started","title":"Alright, lets get started!","text":"<p>Although this chapter  will provide step-by-step instructions, you can always refer to the complete code on Github</p> <p><code>cdk8s</code> makes it really easy for you get started and bootstrap your application. You don't need to guess and figure out how to structure your project, setup dependencies etc. since the <code>cdk8s init</code> command does it for you!</p> <pre><code>cdk8s init go-app\n\n#output\n....\n\n Your cdk8s Go project is ready!\n\n   cat help      Prints this message  \n   cdk8s synth   Synthesize k8s manifests to dist/\n   cdk8s import  Imports k8s API objects to \"imports/k8s\"\n\n  Deploy:\n   kubectl apply -f dist/\n</code></pre> <p>Once completed, you will get a directory structure as such:</p> <pre><code>.\n\u251c\u2500\u2500 cdk8s.yaml\n\u251c\u2500\u2500 dist\n\u2502   \u2514\u2500\u2500 test.k8s.yaml\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 go.sum\n\u251c\u2500\u2500 help\n\u251c\u2500\u2500 imports\n\u2502   \u2514\u2500\u2500 k8s\n\u2502       \u251c\u2500\u2500 internal\n\u2502       \u2502   \u2514\u2500\u2500 types.go\n\u2502       \u251c\u2500\u2500 jsii\n\u2502       \u2502   \u251c\u2500\u2500 jsii.go\n\u2502       \u2502   \u2514\u2500\u2500 k8s-0.0.0.tgz\n\u2502       \u251c\u2500\u2500 k8s.go\n\u2502       \u251c\u2500\u2500 k8s.init.go\n\u2502       \u2514\u2500\u2500 version\n\u2514\u2500\u2500 main.go\n</code></pre> <p>Update the generate <code>go.mod</code> file, and replace it with the following - this is to make things simpler for you. </p> <p>Feel free to use the latest version of the modules if needed.</p> <pre><code>module getting-started-with-cdk8s-go\n\ngo 1.16\n\nrequire (\n    github.com/aws/constructs-go/constructs/v10 v10.1.42\n    github.com/aws/jsii-runtime-go v1.60.1\n    github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.29\n)\n</code></pre>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#youre-all-set-to-write-some-write-some-go-code","title":"You're all set to write some write some Go code!","text":"<p>The canonical Kubernetes \"hello world\" is to get a <code>nginx</code> server up and running. The  easiest option is to use simply use <code>kubectl run</code> e.g. <code>kubectl run nginx --image=nginx</code>. But, since this is imperative, we switch to a declarative way where we define our desired state (in a <code>yaml</code> file) and ask Kubernetes to figure things out. </p> <p>For e.g. we can write a <code>Deployment</code> manifest and submit it to Kubernetes using <code>kubectl apply -f &lt;name of the yaml file</code>&gt;.</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: hello-nginx\n  template:\n    metadata:\n      labels:\n        app: hello-nginx\n    spec:\n      containers:\n        - image: nginx\n          name: nginx-container\n          ports:\n            - containerPort: 8080\n</code></pre>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#but-we-are-here-to-minimise-yaml","title":"But we are here to minimise yaml...","text":"<p>So, open the <code>main.go</code> file and copy the below Go code. Don't worry, I will walk you through it!</p> <pre><code>package main\n\nimport (\n    \"getting-started-with-cdk8s-go/imports/k8s\"\n    \"github.com/aws/constructs-go/constructs/v10\"\n    \"github.com/aws/jsii-runtime-go\"\n    \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\"\n)\n\ntype NginxChartProps struct {\n    cdk8s.ChartProps\n}\n\nfunc NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart {\n    var cprops cdk8s.ChartProps\n    if props != nil {\n        cprops = props.ChartProps\n    }\n    chart := cdk8s.NewChart(scope, jsii.String(id), &amp;cprops)\n\n    selector := &amp;k8s.LabelSelector{MatchLabels: &amp;map[string]*string{\"app\": jsii.String(\"hello-nginx\")}}\n\n    labels := &amp;k8s.ObjectMeta{Labels: &amp;map[string]*string{\"app\": jsii.String(\"hello-nginx\")}}\n\n    nginxContainer := &amp;k8s.Container{Name: jsii.String(\"nginx-container\"), Image: jsii.String(\"nginx\"), Ports: &amp;[]*k8s.ContainerPort{{ContainerPort: jsii.Number(80)}}}\n\n    k8s.NewKubeDeployment(chart, jsii.String(\"deployment\"),\n        &amp;k8s.KubeDeploymentProps{\n            Spec: &amp;k8s.DeploymentSpec{\n                Replicas: jsii.Number(1),\n                Selector: selector,\n                Template: &amp;k8s.PodTemplateSpec{\n                    Metadata: labels,\n                    Spec: &amp;k8s.PodSpec{\n                        Containers: &amp;[]*k8s.Container{nginxContainer}}}}})\n\n    return chart\n}\n\nfunc main() {\n    app := cdk8s.NewApp(nil)\n    NewNginxChart(app, \"nginx\", nil)\n    app.Synth()\n}\n</code></pre> <p>When writing <code>cdk8s</code> based code in any language, you will come across a set of common concepts/terminologies - these include <code>Construct</code>, <code>App</code> and <code>Chart</code>. I will explain these as we walk through the code. </p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#slight-detour-code-walk-through-and-concepts","title":"Slight detour (code walk-through and concepts)","text":"<p>Start with the <code>main</code> function first - we use cdk8s.NewApp to create an App.</p> <p>Well, what exactly in an <code>App</code>? It's is a construct, and you can think of <code>construct</code>s as higher-level building blocks to represent state. The key thing to note is that these constructs are composable. What that means is that you can define levels of these constructs (each level provides/exposes a different abstraction layer) and combine them to create your desired end state - in this case it happens to be a Kubernetes manifest with objects such as <code>Deployment</code>, but it could be something else. </p> <p>For e.g. an AWS CloudFormation template (if you were to use AWS CDK, not be confused with <code>cdk8s</code>)</p> <p>Back to the <code>App</code> - so, an <code>App</code> is also a construct. In fact you can think of it as the root in a tree (hierarchy) of constructs. So what else is there in that tree? Look the second line in the main function - <code>NewNginxChart(app, \"getting-started\", nil)</code> - this invokes a function  <code>NewNginxChart</code> that returns a cdk8s.Chart which is the next component in the hierarchy. AA cdk8s <code>App</code> can contain multiple charts and each chart can be converted (or in precise cdk8s terminology - synthesized) into a separate Kubernetes manifest file (you will see this action very soon). </p> <p>Finally, draw your attention to the <code>NewNginxChart</code> function. It has a bunch of things, but notice the call to <code>k8s.NewKubeDeployment</code> function. This is where we actually define a Kubernetes <code>Deployment</code> in code (in the next section, we will also add a <code>Service</code> to the chart.) </p> <p>You can define multiple Kubernetes components in a chart, such a <code>Pod</code>, <code>Service</code>, <code>Ingress</code>, <code>Job</code> etc. - what ever you need for your application to work on Kubernetes.</p> <p>To summarise, here is a visual representation of what I just explained - remember everything is a <code>Construct</code> (<code>App</code>, <code>Chart</code> etc.)</p> <p></p> <p>Wait, what about the Kubernetes API dependencies??</p> <p>If you've spent time working on accessing Kubernetes programmatically, this is an obvious (and great!) question. if you were to deal with k8s object using go, at the minimum you will need Kubernetes client-go, API machinery etc. Guess what, <code>cdk8s</code> has got you covered there too!</p> <p>You actually don't need to pull in these dependencies because <code>cdk8s</code> allows you to treat these Kubernetes API Objects as <code>constructs</code> - remember, everything is s construct! They are automatically imported to your project when you run the <code>cdk8s init</code> command, but you can do it explicitly using cdk8s import as well. The resulting API is available as part of the <code>imports</code> folder (yes, go ahead and check that again!). On the top of <code>main.go</code>, check the package that is imported - its just refers to the <code>imports</code> folder.</p> <p>There is more to <code>cdk8s import</code> though. More to come in the chapters to follow!</p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#alright-lets-get-back-on-track","title":"Alright, lets get back on track...","text":"<p>.. and continue with the practical bits. It's time to generate some yaml - you can't eliminate it, but at least you don't have to write it by hand! To do so, simply run:</p> <pre><code>cdk8s synth\n</code></pre> <p>Once that completes (should be quick!), check the <code>dist</code> directory to check what <code>cdk8s</code> has generated. To make it easier to understand, here is a diagram which has a one-to-one mapping (notice the labels 1, 2,3, etc.?) between the the <code>cdk8s</code> code objects/properties to their respective counterparts in yaml e.g. <code>spec.replicas</code>, <code>spec.selector</code>, <code>template.spec</code> etc.</p> <p></p> <p>You can now use good old <code>kubectl</code> to deploy this to Kubernetes since <code>cdk8s</code> is not going to do that for you, at least not yet ;)</p> <pre><code>kubectl apply -f dist/\nkubectl get pods -w\n</code></pre> <p>Once the <code>Deployment</code> is ready, the <code>Pod</code> should be in <code>Running</code> state. Simply use <code>port-forward</code> to access the <code>nginx</code> container port locally:</p> <pre><code>kubectl port-forward &lt;enter nginx pod name&gt; 8080:80\n</code></pre> <p>To access <code>nginx</code> home page, navigate to <code>http://localhost:8080</code> using your browser</p> <p>You also use a CLI tool e.g. <code>curl localhost:8080</code>.</p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#thats-not-all","title":"That's not all!","text":"<p>Instead of port forwarding, let's use the standard Kubernetes way of accessing applications by defining a <code>Service</code> resource, which is typically defined like this:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\nspec:\n  ports:\n    - port: 9090\n      targetPort: 8080\n  selector:\n    app: hello-nginx\n  type: LoadBalancer\n</code></pre> <p>But you know the rule - no yaml writing by hand! So, in the <code>NewNginxChart</code> function in the <code>main.go</code> file, add this piece of code after the part you defined the <code>Deployment</code>:</p> <pre><code>    k8s.NewKubeService(chart, jsii.String(\"service\"), &amp;k8s.KubeServiceProps{\n        Spec: &amp;k8s.ServiceSpec{\n            Type:     jsii.String(\"LoadBalancer\"),\n            Ports:    &amp;[]*k8s.ServicePort{{Port: jsii.Number(9090), TargetPort: k8s.IntOrString_FromNumber(jsii.Number(80))}},\n            Selector: &amp;map[string]*string{\"app\": jsii.String(\"hello-nginx\")}}})\n</code></pre> <p>First, delete the existing <code>Deployment</code> - <code>kubectl delete -f dist/</code>. Then, run <code>cdk8s synth</code> again to create the new manifest in the <code>dist</code> folder.</p> <p>Both the <code>Service</code> and <code>Deployment</code> are in the same file - this is because they are part of the same Chart.</p> <p>How you access the service will depend on the Kubernetes cluster. If you are using a cloud provider, it will likely provision a Load Balancer service native to that cloud e.g. Application Load Balancer in AWS. Please adjust this as per your setup.</p> <p>For <code>minikube</code>, you can simply follow these instructions https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access - \"Services of type LoadBalancer can be exposed via the <code>minikube tunnel</code> command.\"</p> <p>In a terminal, run this command (it runs as a separate process):</p> <pre><code>minikube tunnel\n</code></pre> <p>In another terminal, delete the existing <code>Deployment</code> and then apply the new manifest:</p> <pre><code>kubectl apply -f dist/\nkubectl get pods -w\n</code></pre> <p>Check the <code>Service</code>:</p> <pre><code>kubectl get svc\n</code></pre> <p>To access the <code>nginx</code> server, navigate to the external IP (as per the <code>Service</code>). In the case of minikube, you can simply use <code>localhost:9090</code> or <code>127.0.0.0:9090</code></p> <p>Remember to use port <code>9090</code> since that's the external port we specified in the Service configuration in our code</p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#before-wrapping-up","title":"Before wrapping up...","text":"<p>.. I want to call out a couple of other useful things in <code>cdk8s</code>.</p> <p>Reference and reuse existing manifests and Helm charts</p> <p>Say you have a <code>Service</code> already defined in a <code>service.yaml</code> file. You can include it in your <code>cdk8s</code> as part of a larger application/chart that you may have. Here is an example:</p> <pre><code>cdk8s.NewInclude(chart, jsii.String(\"existing service\"), &amp;cdk8s.IncludeProps{Url: jsii.String(\"service.yaml\")})\n</code></pre> <p>Similarly, you can also include <code>Helm</code> charts. Say you wanted to add <code>bitnami/nginx</code>:</p> <pre><code>cdk8s.NewHelm(chart, jsii.String(\"bitnami nginx helm chart\"), &amp;cdk8s.HelmProps{\n        Chart:  jsii.String(\"bitnami/nginx\"),\n        Values: &amp;map[string]interface{}{\"service.type\": \"ClusterIP\"}})\n</code></pre> <p>Well, you do need to have <code>helm</code> installed locally and also add the repo first <code>helm repo add bitnami https://charts.bitnami.com/bitnami</code> </p> <p>Another handy feature is...</p> <p>... the ability to declare dependencies between any two <code>cdk8s</code> constructs. For instance, in the previous example, we had a <code>Deployment</code> and a <code>Service</code>. You could create a dependency as such:</p> <pre><code>deployment := k8s.NewKubeDeployment(...)\nservice := k8s.NewKubeService(...)\n\ndeployment.AddDependency(service)\n</code></pre> <p>Thanks to <code>AddDependency</code>, the resulting manifest will be such that the <code>Service</code> is placed before the <code>Deployment</code> object. </p> <p>Dependency is not limited to individual constructs in a chart. If you have multiple charts as part of your <code>cdk8s</code> app, you can establish dependencies across charts as well.</p>"},{"location":"Part%201%3A%20Getting%20started%20with%20cdk8s/#conclusion","title":"Conclusion","text":"<p>Awesome. So you were able to \"code\" your way through trouble and ignore YAML. Hope you enjoyed it! To keep things simple, I demonstrated a <code>Deployment</code> and <code>Service</code>, but you can choose from other Kubernetes components such as <code>Ingress</code>, <code>Job</code> etc. They are all exposed using a similar pattern i.e. NewKube for e.g. <code>NewKubeJob</code>, <code>NewKubeIngress</code> etc.  <p>But there is still a lot of boilerplate code involved in defining Kubernetes components. Writing Go code sounds way better than YAML engineering (at least to me), it seems as if we are translating existing YAML into Go structs (and fields). In the next chapter, we will explore how to improve this further.</p>"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/","title":"cdk8s-plus in action!","text":"<p>The previous chapter covered how to get started with cdk8s (Cloud Development Kit for Kubernetes), that is an an open-source framework (part of CNCF) using which you can define your Kubernetes applications using regular programming languages (instead of <code>yaml</code>). </p> <p>You were able to setup a simple <code>nginx</code> Deployment and accessed it via a <code>Service</code> - all this was done using Go, which was then converted to <code>yaml</code> (using <code>cdk8s synth</code>) and submitted to the cluster using <code>kubectl</code>. This was a good start. However, since the core <code>cdk8s</code> library is pretty low-level (for a good reason!) the code involved lot of boilerplate (you can refer to the code here). </p> <p><code>cdk8s-plus</code> leverages building blocks from <code>cdk8s</code> core library, thereby helping reduce verbosity and complexity by providing higher level abstractions/APIs for all Kubernetes objects such as <code>Deployment</code>s, <code>Service</code>s, etc. In this blog, we will see <code>cdk8s-plus</code> in action and even deploy Wordpress on Kubernetes with it!</p>"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#lets-start-by-revamping-the-nginx-deployment","title":"Let's start by revamping the Nginx deployment..","text":"<p>To witness how <code>cdk8s-plus</code> works, it's best to look at the code. </p> <p>It is available on Github.</p> <p>I will walk you through the code as we go along.</p> <pre><code>func NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart {\n    var cprops cdk8s.ChartProps\n    if props != nil {\n        cprops = props.ChartProps\n    }\n    chart := cdk8s.NewChart(scope, jsii.String(id), &amp;cprops)\n\n    dep := cdk8splus22.NewDeployment(chart, jsii.String(\"deployment\"), &amp;cdk8splus22.DeploymentProps{Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(\"nginx-deployment-cdk8s-plus\")}})\n\n    dep.AddContainer(&amp;cdk8splus22.ContainerProps{\n        Name:  jsii.String(\"nginx-container\"),\n        Image: jsii.String(\"nginx\"),\n        Port:  jsii.Number(80)})\n\n    dep.ExposeViaService(&amp;cdk8splus22.DeploymentExposeViaServiceOptions{\n        Name:        jsii.String(\"nginx-container-service\"),\n        ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,\n        Ports:       &amp;[]*cdk8splus22.ServicePort{{Port: jsii.Number(9090), TargetPort: jsii.Number(80)}}})\n\n    return chart\n}\n</code></pre> <p>We start by creating a Deployment, then add a container and finally expose it using a Service. This is quite intuitive and user-friendly.</p> <p>The container details could have been provided via DeploymentProps but using <code>AddContainer</code> seemed more natural (at least to me).</p> <p>To generate Kubernetes manifest, simply run <code>cdk8s synth</code>. This will generate a <code>yaml</code> in the <code>dist</code> folder. Here is an example (some of the names, labels etc. will be different in your case): </p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment-cdk8s-plus\nspec:\n  minReadySeconds: 0\n  progressDeadlineSeconds: 600\n  replicas: 1\n  selector:\n    matchLabels:\n      cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e\n  strategy:\n    rollingUpdate:\n      maxSurge: 25%\n      maxUnavailable: 25%\n    type: RollingUpdate\n  template:\n    metadata:\n      labels:\n        cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e\n    spec:\n      automountServiceAccountToken: true\n      containers:\n        - image: nginx\n          imagePullPolicy: Always\n          name: nginx-container\n          ports:\n            - containerPort: 80\n          securityContext:\n            privileged: false\n            readOnlyRootFilesystem: false\n            runAsNonRoot: false\n      dnsPolicy: ClusterFirst\n      securityContext:\n        fsGroupChangePolicy: Always\n        runAsNonRoot: false\n      setHostnameAsFQDN: false\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-container-service\nspec:\n  externalIPs: []\n  ports:\n    - port: 9090\n      targetPort: 80\n  selector:\n    cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e\n  type: LoadBalancer\n</code></pre> <p>Both the <code>Deployment</code> and <code>Service</code> are present in the same manifest, since they were declared in the same <code>Chart</code>. </p> <p>It's worth noting that there was no need to specify any <code>Pod</code> label selectors, template labels (in <code>Deployment</code> code) or <code>Service</code> selector. <code>cdk8s-plus</code> took care of it by auto-generating <code>cdk8s.io/metadata.addr: nginx-cdk8s-plus-deployment-c84b388e</code>, which was used in s<code>pec.selector.matchLabels</code> and <code>spec.template.metadata.labels</code>, along with the Service <code>selector</code> in <code>nginx-container-service</code></p> <p>A note on dependencies</p> <p><code>go.mod</code> lists all the modules:</p> <pre><code>require (\n    github.com/aws/constructs-go/constructs/v10 v10.1.42\n    github.com/aws/jsii-runtime-go v1.61.0\n    github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.31\n    github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22/v2 v2.0.0-rc.23\n)\n</code></pre> <p>Note that we are using <code>cdk8splus22</code>. The reason for this naming convention is because  each <code>cdk8s-plus</code> library is separately vended to target a specific Kubernetes version - the <code>22</code> at the end signifies that this dependency will work with Kubernetes <code>1.22</code></p> <p>I would recommend reading the FAQs to get further clarity</p> <p>To test this locally...</p> <p>... you can use minikube, kind, etc.</p> <pre><code>git clone https://github.com/abhirockzz/cdk8s-for-go-developers\ncd part2-cdk8s-plus-in-action/nginx-example\n\n# make sure cluster is running\nminikube start\n\n# create the resources\nkubectl apply -f dist/\nkubectl get pods -w\n</code></pre> <p>Once <code>Pod</code> is running, check the <code>Service</code>:</p> <pre><code>kubectl get svc\n</code></pre> <p>In a terminal, run this command (it runs as a separate process):</p> <pre><code>minikube tunnel\n</code></pre> <p>To access the <code>nginx</code> server, navigate to the external IP (as per the <code>Service</code>). In the case of minikube, you can simply use <code>localhost:9090</code> or <code>127.0.0.0:9090</code></p>"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#how-about-a-wordpress-installation-on-kubernetes","title":"How about a Wordpress installation on Kubernetes?","text":"<p>I like this example - it's not overly complex but realistic enough because it has multiple moving parts that includes a combination of stateless, stateful components, different kinds of services etc.</p> <p>This chapter is not a deep dive into <code>Wordpress</code> and loosely inspired by this article in the Kubernetes documentation, which I assume folks might be familiar with.</p> <p>The <code>main</code> function will give you a sense of what lies ahead:</p> <pre><code>func main() {\n    app := cdk8s.NewApp(nil)\n\n    mySQLChart := NewMySQLChart(app, \"mysql\", nil)\n    wordpressChart := NewWordpressChart(app, \"wordpress\", nil)\n\n    wordpressChart.AddDependency(mySQLChart)\n\n    app.Synth()\n}\n</code></pre> <p>So far, we have dealt with a single chart. Our Wordpress <code>cdk8s</code> application has two separate charts - one for MySQL database and the other one for Wordpress. This will result in two different manifests being created as a result of <code>cdk8s synth</code> process.</p> <p>Let's look the MySQL chart first</p> <p>some code has been omitted for brevity</p> <p>We start by defining a Kubernetes <code>Secret</code> to store MySQL password (with NewSecret):</p> <pre><code>func NewMySQLChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {\n    //....\n    secretName := \"mysql-pass\"\n    password := \"Password123\"\n\n    mysqlSecret := cdk8splus22.NewSecret(chart, jsii.String(\"mysql-secret\"),\n        &amp;cdk8splus22.SecretProps{\n            Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)}})\n\n    secretKey := \"password\"\n    mysqlSecret.AddStringData(jsii.String(secretKey), jsii.String(password))\n</code></pre> <p>MySQL password has been declared in the code - not a best practice by any means, just for demo. Do not do this in production!</p> <p>Then we create the <code>Deployment</code> and provide container details. Notice how the <code>Secret</code> has been added as an environment variable to the container: - First we got an EnvValue using EnvValue_FromSecretValue - That was added to the container using Env#AddVariable</p> <pre><code>    dep := cdk8splus22.NewDeployment(chart, jsii.String(\"mysql-deployment-cdk8splus\"), &amp;cdk8splus22.DeploymentProps{})\n\n    containerImage := \"mysql\"\n\n    mysqlContainer := dep.AddContainer(&amp;cdk8splus22.ContainerProps{\n        Name:  jsii.String(\"mysql-container\"),\n        Image: jsii.String(containerImage),\n        Port:  jsii.Number(3306),\n    })\n\n    envValFromSecret := cdk8splus22.EnvValue_FromSecretValue(&amp;cdk8splus22.SecretValue{Key: jsii.String(secretKey), Secret: mysqlSecret}, &amp;cdk8splus22.EnvValueFromSecretOptions{Optional: jsii.Bool(false)})\n\n    mySQLPasswordEnvName := \"MYSQL_ROOT_PASSWORD\"\n\n    mysqlContainer.Env().AddVariable(jsii.String(mySQLPasswordEnvName), envValFromSecret)\n</code></pre> <p>For durable storage, we create a PersistentVolumeClaim, use that to define a Volume and mount in onto the container at the path <code>/var/lib/mysql</code>.</p> <pre><code>    mysqlPVC := cdk8splus22.NewPersistentVolumeClaim(chart, jsii.String(\"mysql-pvc\"), &amp;cdk8splus22.PersistentVolumeClaimProps{\n        AccessModes: &amp;[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE},\n        Storage:     cdk8s.Size_Gibibytes(jsii.Number(2))})\n\n    mysqlVolumeName := \"mysql-persistent-storage\"\n    mysqlVolume := cdk8splus22.Volume_FromPersistentVolumeClaim(chart, jsii.String(\"mysql-vol-pvc\"), mysqlPVC, &amp;cdk8splus22.PersistentVolumeClaimVolumeOptions{Name: jsii.String(mysqlVolumeName)})\n\n    mySQLVolumeMountPath := \"/var/lib/mysql\"\n    mysqlContainer.Mount(jsii.String(mySQLVolumeMountPath), mysqlVolume, &amp;cdk8splus22.MountOptions{})\n</code></pre> <p>Finally, we create a Service:</p> <pre><code>    mySQLServiceName := \"mysql-service\"\n    clusterIPNone := \"None\"\n\n    cdk8splus22.NewService(chart, jsii.String(\"mysql-service\"), &amp;cdk8splus22.ServiceProps{\n        Metadata:  &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(mySQLServiceName)},\n        Selector:  dep,\n        ClusterIP: jsii.String(clusterIPNone),\n        Ports:     &amp;[]*cdk8splus22.ServicePort{{Port: jsii.Number(3306)}},\n    })\n</code></pre> <p>Unlike previous example, we create a <code>Service</code> explicitly and then refer to <code>Deployment</code> object in the service selector.</p> <p>Wordpress Chart - Except for minor differences, it's the same as the MySQL chart with Wordpress specific configuration obviously. So I won't repeat it here - feel free to explore the code.</p>"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#the-moment-of-truth-is-here","title":"The moment of truth is here!","text":"<p>Rinse and repeat - <code>cdk8s synth</code> to create the manifest and apply it with <code>kubectl</code>:</p> <pre><code>cd part2-cdk8s-plus-in-action/wordpress\n\n#create manifests\ncdk8s synth\n\n#apply them\nkubectl apply -f dist/\n\n#output - you will see something similar to:\n\nsecret/mysql-pass created\ndeployment.apps/mysql-mysql-deployment-cdk8splus-c83762d9 created\npersistentvolumeclaim/mysql-mysql-pvc-c8799bba created\nservice/mysql-service created\ndeployment.apps/wordpress-wordpress-deployment-cdk8splus-c8252da7 created\nservice/wordpress-service created\npersistentvolumeclaim/wordpress-wordpress-pvc-c8334a29 created\n</code></pre> <p>In a different terminal run (if not already running):</p> <pre><code>minikube tunnel\n</code></pre> <p>Use your browser to navigate to http://localhost:80. You should see the familiar Wordpress installation screen.</p> <p></p> <p>Go ahead, finish the installation and log into your Wordpress instance. Feel free to experiment. Maybe try deleting the MySQL deployment and re-creating it. Thanks to the <code>PersistentVolume</code>, MySQL data should be recovered and wordpress will continue to work.</p>"},{"location":"Part%202%3A%20cdk8s-plus%20in%20action/#conclusion","title":"Conclusion","text":"<p>Awesome! In this chapter you saw the expressiveness of <code>cdk8s-plus</code>. We started off with a compact and less verbose version of the Nginx deployment and ended up with a full-fledged Wordpress instance - all  using Go.</p>"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/","title":"Using Custom Resource Definitions with cdk8s","text":"<p>cdk8s (Cloud Development Kit for Kubernetes) is an an open-source framework (part of CNCF) using which you can define your Kubernetes applications with regular programming languages (instead of <code>yaml</code>). One of the previous chapter covered the getting started experience and using <code>cdk8s-plus</code> library to further improve upon the core <code>cdk8s</code> library features. We are going to continue and push <code>cdk8s</code> even further.  This chapter  will demonstrate how you can use Kubernetes Custom Resource Definitions with <code>cdk8s</code>. We will start off with a simple <code>Nginx</code> example and then you will use the combination of Strimzi project CRDs along with Go and <code>cdk8s</code> to define and deploy a Kafka cluster on Kubernetes!</p> <p>I am assuming that you've have some knowledge of Kubernetes Custom Resource Definitions and have probably even used a few in the form of Operators. If not, that's ok! The Kubernetes documentation covers it quite well. You can always refer to it, come back here and follow along!</p> <p><code>cdk8s</code> lets you use Kubernetes API objects directly in your code, without having to import individual Go client packages, all thanks to <code>cdk8s import</code>. (also mentioned in the \"Wait, what about the Kubernetes API dependencies??\" section the previous chapter. But you can also use it for Custom Resource Definitions! Let's see this in action.</p>"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#before-you-begin","title":"Before you begin...","text":"<p>Make sure you have <code>Go</code> (v1.16 or above) and cdk8s CLI installed. Also, you need to have access to a Kubernetes cluster. For learning and experimentation I would recommend using a single-node cluster running locally - such as minikube, kind, etc.</p> <p>I generally use <code>minikube</code>, so setting up a cluster is as simple as <code>minikube start</code></p> <p>To install cdk8s CLI</p> <p>You can choose from the below options:</p> <pre><code>#homebrew\nbrew install cdk8s\n\n#npm\nnpm install -g cdk8s-cli\n\n#yarn\nyarn global add cdk8s-cli\n</code></pre>"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#alright-lets-get-started","title":"Alright, lets get started...","text":"<p>Although this chapter will provide step-by-step instructions, you can always refer to the complete code on Github</p> <p><code>cdk8s</code> makes it really easy for you get started and bootstrap your application. You don't need to guess and figure out how to structure your project, setup dependencies etc. since the <code>cdk8s init</code> command does it for you!</p> <pre><code>cdk8s init go-app\n\n#output\n....\n\n Your cdk8s Go project is ready!\n\n   cat help      Prints this message  \n   cdk8s synth   Synthesize k8s manifests to dist/\n   cdk8s import  Imports k8s API objects to \"imports/k8s\"\n\n  Deploy:\n   kubectl apply -f dist/\n</code></pre> <p>Update the generate <code>go.mod</code> file, and replace it with the following - this is to make things simpler for you. </p> <p>Feel free to use the latest version of the modules if needed.</p> <pre><code>module cdk8s-crd\n\ngo 1.16\n\nrequire (\n    github.com/aws/constructs-go/constructs/v10 v10.1.42\n    github.com/aws/jsii-runtime-go v1.61.0\n    github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.34\n)\n</code></pre> <p>To start with, let's work with a really (really!) simple Custom Resource Definition</p> <p>I am going to use a sample CRD from the Kubernetes example. To be honest, it doesn't really do anything. But, since we're just getting started, this should suffice!</p> <p>First, install/register the <code>CRD</code> resource itself:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/sample-controller/master/artifacts/examples/crd.yaml\n</code></pre> <p>Confirm whether the <code>CRD</code> was installed:</p> <pre><code>kubectl get crd\n\n# output\nNAME                           CREATED AT\nfoos.samplecontroller.k8s.io   2022-07-08T09:28:46Z\n\nkubectl get foos.samplecontroller.k8s.io\n\n#output (as expected)\nNo resources found in default namespace.\n</code></pre> <p>So, we just installed a <code>CRD</code> with the name <code>foos.samplecontroller.k8s.io</code> and type <code>Foo</code>. Its possible to create an instance of this using <code>yaml</code>... but...</p> <p>We are here to write Go code!</p> <p>To do that, first import the <code>CRD</code> as an API using <code>cdk8s</code> - this will automatically create the corresponding Go API representations (<code>struct</code>s etc.):</p> <pre><code>cdk8s import https://raw.githubusercontent.com/kubernetes/sample-controller/master/artifacts/examples/crd.yaml\n</code></pre> <p>Check the <code>imports</code> directory, an additional folder should have been created. </p> <pre><code>imports/\n\u2514\u2500\u2500 samplecontrollerk8sio\n    \u251c\u2500\u2500 internal\n    \u2502   \u2514\u2500\u2500 types.go\n    \u251c\u2500\u2500 jsii\n    \u2502   \u251c\u2500\u2500 jsii.go\n    \u2502   \u2514\u2500\u2500 samplecontrollerk8sio-0.0.0.tgz\n    \u251c\u2500\u2500 samplecontrollerk8sio.go\n    \u251c\u2500\u2500 samplecontrollerk8sio.init.go\n    \u2514\u2500\u2500 version\n</code></pre> <p>We can now use the <code>CRD</code> just like any other Kubernetes resource/API (like <code>Deployment</code>) and import it in the <code>cdk8s</code> Go code. Create a new file called <code>foo.go</code> and copy the following code:</p> <pre><code>package main\n\nimport (\n    \"cdk8s-crd/imports/samplecontrollerk8sio\"\n\n    \"github.com/aws/constructs-go/constructs/v10\"\n    \"github.com/aws/jsii-runtime-go\"\n    \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\"\n)\n\ntype FooChartProps struct {\n    cdk8s.ChartProps\n}\n\nfunc NewFooChart(scope constructs.Construct, id string, props *FooChartProps) cdk8s.Chart {\n    var cprops cdk8s.ChartProps\n    if props != nil {\n        cprops = props.ChartProps\n    }\n    chart := cdk8s.NewChart(scope, jsii.String(id), &amp;cprops)\n\n    samplecontrollerk8sio.NewFoo(chart, jsii.String(\"foo1\"), &amp;samplecontrollerk8sio.FooProps{Spec: &amp;samplecontrollerk8sio.FooSpec{DeploymentName: jsii.String(\"foo1-dep\"), Replicas: jsii.Number(2)}})\n\n    return chart\n}\n</code></pre> <p>See how we created an instance of <code>samplecontrollerk8sio.Foo</code>: - Imported the autogenerated CRD API from the <code>cdk8s-crd/imports/samplecontrollerk8sio</code> package, - Used the <code>NewFoo</code> function and provided the metadata via <code>FooProps</code></p> <p>Replace the contents of <code>main.go</code> with the following:</p> <pre><code>package main\n\nimport (\n    \"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2\"\n)\n\ntype MyChartProps struct {\n    cdk8s.ChartProps\n}\n\nfunc main() {\n    app := cdk8s.NewApp(nil)\n    NewFooChart(app, \"FooApp\", nil)\n    app.Synth()\n}\n</code></pre> <p>All we is include the <code>Chart</code> that we defined just now (in <code>foo.go</code>) and include it in the <code>cdk8s</code> <code>App</code>.</p> <p>To create the <code>Foo</code> resource...</p> <p>Run <code>cdk8s synth</code> - this will result in a manifest in the <code>dist</code> folder:</p> <pre><code>apiVersion: samplecontroller.k8s.io/v1alpha1\nkind: Foo\nspec:\n  deploymentName: foo1-dep\n  replicas: 2\nmetadata:\n  name: fooapp-foo1-c80094ac\n</code></pre> <p>To create it in Kubernetes:</p> <pre><code>kubectl apply -f dist\n</code></pre> <p>You can confirm by running :</p> <pre><code>kubectl get foo\nkubectl get foos.samplecontroller.k8s.io\n</code></pre> <p>To introspect further, you can use the name of the created resource e.g. <code>kubectl describe foo/fooapp-foo1-c80094ac</code></p> <p>Alright, now that you've seen a simple example, we can move on to something slightly more advanced.</p>"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#setup-kafka-on-kubernetes-using-strimzi-cdk8s-and-go","title":"Setup Kafka on Kubernetes using Strimzi, <code>cdk8s</code> and Go","text":"<p>Strimzi is an open-source CNCF project and one of my personal favourites! If you don't know about Strimzi, that's ok. It's enough to understand that it provides a way to run an Apache Kafka on Kubernetes with the help of Custom Resource Definitions and corresponding Operators for components such as Kafka cluster, Kafka Connect topic, users, Kafka Mirror etc. </p> <p>Here is a high-level diagram of how the different Strimzi components interact. Since a Strimzi deep-dive is out of scope, I would recommend that you refer its (excellent!) documentation for details.</p> <p></p> <p>As before, we need to first install the CRD itself (you can also refer to the Strimzi Quickstart)</p> <pre><code>kubectl create namespace kafka\nkubectl create -f 'https://strimzi.io/install/latest?namespace=kafka' -n kafka\n\n# wait for the Operator Pod to start up (Running)\nkubectl get pod -n kafka --watch\n</code></pre> <p>You can also check the Operator logs using <code>kubectl logs deployment/strimzi-cluster-operator -n kafka -f</code></p> <p>Each supported Kafka component (cluster, connect, user etc.) has a corresponding Custom Resource Definition - for the purposes of this chapter, we will just use the Kafka cluster and topic CRDs. Let's import them as an API:</p> <pre><code>cdk8s import https://raw.githubusercontent.com/strimzi/strimzi-kafka-operator/main/install/cluster-operator/040-Crd-kafka.yaml\n\ncdk8s import kafkatopic:=https://raw.githubusercontent.com/strimzi/strimzi-kafka-operator/main/install/cluster-operator/043-Crd-kafkatopic.yaml\n</code></pre> <p>Note that I've prepended <code>kafkatopic</code> to the module name for Kafka topic CRD</p> <p>Check the <code>imports</code> folder - you should see two additional folders named <code>kafkastrimziio</code> and <code>kafkatopic_kafkastrimziio</code>.</p> <p>Time for some Go code, again</p> <p>Create a <code>kafka_strimzi.go</code> file and copy the code from Github repo:</p> <p>Or you can also simply do this: <code>curl -o kafka.go https://raw.githubusercontent.com/abhirockzz/cdk8s-for-go-developers/master/part3-crd/kafka_strimzi.go</code></p> <p>I will walk you through the important parts of the code here. Start with the <code>NewKafkaChart</code> function that creates a new <code>Chart</code>.</p> <pre><code>func NewKafkaChart(scope constructs.Construct, id string, props *KafkaChartProps) cdk8s.Chart {\n    //.... ommitted for brevity\n    chart := cdk8s.NewChart(scope, jsii.String(id), &amp;cprops)\n</code></pre> <p>See how the Kafka cluster is defined using <code>kafkastrimziio.KafkaProps</code> struct (for a deep-dive into each of these components you can refer to Strimzi documentation). We specify the Kafka version, number of nodes/replicas (we will stick to a single node replica) how to expose the cluster etc. </p> <pre><code>//....\n&amp;kafkastrimziio.KafkaProps{\n            Spec: &amp;kafkastrimziio.KafkaSpec{\n                Kafka: &amp;kafkastrimziio.KafkaSpecKafka{\n\n                    Version:  jsii.String(\"3.2.0\"),\n                    Replicas: jsii.Number(1),\n                    Listeners: &amp;[]*kafkastrimziio.KafkaSpecKafkaListeners{\n                        {\n                            Name: jsii.String(\"plain\"),\n                            Port: jsii.Number(9092),\n                            Type: kafkastrimziio.KafkaSpecKafkaListenersType_INTERNAL,\n                            Tls:  jsii.Bool(false),\n                        },\n                    },\n//....\n</code></pre> <p>Then we add required config for the Kafka cluster (in-line with the fact that we have a single node cluster only) as well as storage (ephemeral storage will work for this example).</p> <pre><code>//...\nConfig: map[string]interface{}{\n                        \"offsets.topic.replication.factor\":         1,\n                        \"transaction.state.log.replication.factor\": 1,\n                        \"transaction.state.log.min.isr\":            1,\n                        \"default.replication.factor\":               1,\n                        \"min.insync.replicas\":                      1,\n                        \"inter.broker.protocol.version\":            \"3.2\",\n                    },\n                    Storage: &amp;kafkastrimziio.KafkaSpecKafkaStorage{\n                        Type: kafkastrimziio.KafkaSpecKafkaStorageType_EPHEMERAL,\n                    },\n//...\n</code></pre> <p>Finally, we configure Zookeeper as well as the Entity operator that handles Kafka topics (as well as users, although we don't use it here)</p> <pre><code>//...\nZookeeper: &amp;kafkastrimziio.KafkaSpecZookeeper{\n                    Replicas: jsii.Number(1),\n                    Storage: &amp;kafkastrimziio.KafkaSpecZookeeperStorage{\n                        Type: kafkastrimziio.KafkaSpecZookeeperStorageType_EPHEMERAL,\n                    },\n                },\n                EntityOperator: &amp;kafkastrimziio.KafkaSpecEntityOperator{\n                    TopicOperator: &amp;kafkastrimziio.KafkaSpecEntityOperatorTopicOperator{},\n                }}})\n//...\n</code></pre> <p>To wire it up, update the <code>main.go</code> file:</p> <pre><code>func main() {\n    app := cdk8s.NewApp(nil)\n    //NewFooChart(app, \"FooApp\", nil)\n    NewKafkaChart(app, \"KafkaApp\", nil)\n    app.Synth()\n}\n</code></pre> <p>To create a Kafka cluster using the CRD...</p> <p>Follow the the usual workflow: </p> <pre><code># generate manifest (check it in dist folder)\ncdk8s synth\n\n# apply it (note the kafka namespace)\nkubectl apply -f dist/ -n kafka\n</code></pre> <p>Wait for the resources to be created:</p> <pre><code>KAFKA_CRD_INSTANCE_NAME=$(kubectl get kafka -n kafka -o=jsonpath='{.items[0].metadata.name}')\nkubectl wait kafka/$KAFKA_CRD_INSTANCE_NAME --for=condition=Ready --timeout=300s -n kafka\n</code></pre> <p>Once all the Kafka cluster resources are created, you should see the following message - <code>kafka.kafka.strimzi.io/&lt;name of your Kafka CRD instance&gt; condition met</code>. The Kafka cluster is now ready and we can test it using the good old Kafka CLI based producer and consumer (instructions in Strimzi quickstart).</p> <pre><code>BOOSTRAP_SERVER=$(kubectl get kafka -n kafka -o=jsonpath='{.items[0].metadata.name}')-kafka-bootstrap\n\nkubectl -n kafka run kafka-producer -ti --image=quay.io/strimzi/kafka:0.29.0-kafka-3.2.0 --rm=true --restart=Never -- bin/kafka-console-producer.sh --bootstrap-server $BOOSTRAP_SERVER:9092 --topic test-topic\n\nkubectl -n kafka run kafka-consumer -ti --image=quay.io/strimzi/kafka:0.29.0-kafka-3.2.0 --rm=true --restart=Never -- bin/kafka-console-consumer.sh --bootstrap-server $BOOSTRAP_SERVER:9092 --topic test-topic --from-beginning\n</code></pre> <p></p> <p>That's all for now!</p>"},{"location":"Part%203%3A%20Using%20Custom%20Resource%20Definitions%20with%20cdk8s/#time-to-wrap-up","title":"Time to wrap up...","text":"<p>You learnt how to combine Kubernetes Custom Resource definition with <code>cdk8s</code>. This is really powerful and means that you can continue to use code (in this case, written in Go) to define built-in Kubernetes resources (like <code>Deployment</code>s etc.) as well as Custom resources!</p> <p>Did you like what you tried?</p> <p>Well, you can continue learning! Couple of suggestions:</p> <ol> <li>You can try updating the existing code to add a <code>Deployment</code> resource that refers to a Kafka client app (you have to write it and package it as a Docker container first) and can access the Kafka cluster you created. Explore how you can get the connectivity parameters..</li> <li>The Kafka cluster we created was configured to have Internal access only. Explore options to expose it externally (refer to Strimzi documentation) and update the code to implement that (should be a small change). Which Kubernetes objects will be affected by it?</li> </ol>"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/","title":"Extend cdk8s with custom Constructs","text":"<p>Constructs are the fundamental building block of cdk8s (Cloud Development Kit for Kubernetes) - an open-source framework (part of CNCF) with which you can define your Kubernetes applications using regular programming languages (instead of <code>yaml</code>). In Getting started with cdk8s, you saw how to use the core <code>cdk8s</code> library.</p> <p>You can also use the <code>cdk8s-plus</code> library (as covered in an earlier chapter) to reduce the amount of boilerplate code you need to write. With <code>cdk8s-plus</code>, creating a Kubernetes <code>Deployment</code>, specifying it's container (and other properties) and exposing it via a <code>Service</code> is three function calls away. </p> <p>For example, to setup and access <code>Nginx</code>, you simply need this:</p> <pre><code>//...\ndeployment := cdk8splus22.NewDeployment(chart, jsii.String(\"deployment\"), &amp;cdk8splus22.DeploymentProps{Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(\"nginx-deployment-cdk8s-plus\")}})\n\ndeployment.AddContainer(&amp;cdk8splus22.ContainerProps{\n        Name:  jsii.String(\"nginx-container\"),\n        Image: jsii.String(\"nginx\"),\n        Port:  jsii.Number(80)})\n\ndeployment.ExposeViaService(&amp;cdk8splus22.DeploymentExposeViaServiceOptions{\n        Name:        jsii.String(\"nginx-container-service\"),\n        ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,\n        Ports:       &amp;[]*cdk8splus22.ServicePort{{Port: jsii.Number(9090), TargetPort: jsii.Number(80)}}})\n//...\n</code></pre> <p>But things can get even better! </p> <p>Instead of writing the same logic over and over, you can package it in the form of a reusable component that can be invoked just like other built-in <code>cdk8s</code> functions (e.g. NewDeployment, <code>NewService</code> etc.). Although it might not sound as useful for the simple application(s), this approach is invaluable for a large project, team or organisation who want to scale their engineering efforts. In fact, there is already a pool of ready-to-use components available at constructs.dev. These include constructs contributed by the community, AWS and others as well, across multiple programming languages.</p>"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/#to-better-understand-how-this-might-look-in-practice","title":"To better understand how this might look in practice","text":"<p>... let's look at the code. I will continue to use <code>Wordpress</code> as an example, like I did in the previous chapter. Here is a code snippet that shows how everything is wired together (with implementation walk-through in the next section):</p> <p>You can refer to the complete code on Github</p> <pre><code>//...\n\nfunc NewMyChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {\n    //....\n    NewWordpressStack(chart, jsii.String(\"wordpress-stack\"), &amp;WordpressProps{//....)\n    return chart\n}\n\nfunc main() {\n    app := cdk8s.NewApp(nil)\n    NewMyChart(app, \"wordpress-custom-stack\", nil)\n    app.Synth()\n}\n</code></pre> <ul> <li><code>NewWordpressStack</code> gives us a construct that represents an entire <code>Wordpress</code> installation (single line of code!)</li> <li>We simply configure it as per our requirements (with <code>WordpressProps</code>)</li> <li>Include this as part of a cdk8s.Chart which is then included in the cdk8s.App (as with any other <code>cdk8s</code> application)</li> </ul> <p>There is lot of flexibility in terms of how you want to build a custom construct, depending on your requirements. But, at its very core, the basic concept is to define a way to create a new construct.Construct. You would want to provide a way to add metadata to further configure/refine your <code>Construct</code> - typically, thats done through properties (cdk8s.ChartProps).</p> <p>First we define <code>WordpressProps</code> - this encapsulates/externalises the attributes of the Wordpress installation. Since this is just an example, I have provided limited attributes such as MySQL/Wordpress Docker images,  MySQL password, and required storage.</p> <pre><code>type WordpressProps struct {\n    MySQLImage    *string\n    MySQLPassword *string\n    MySQLStorage  *float64\n\n    WordpressImage   *string\n    WordpressStorage *float64\n}\n</code></pre> <p>Then we have a function that will allow other charts/constructs to instantiate Wordpress. This is where the entire implementation resides.</p> <pre><code>func NewWordpressStack(scope constructs.Construct, id *string, props *WordpressProps) constructs.Construct {\n    ...\n}\n</code></pre> <p>The <code>props *WordpressProps</code> parameter allows other constructs to influence the Wordpress stack creation e.g. you can define how much storage you need, maybe use a different Docker image for Wordpress/MySQL.  The actual code for this function is similar to the one you saw here (with required adjustments), so there is no point repeating it here. I will simply highlight the important bits - specifically the ones that use the <code>props</code> to configure the required components.</p> <p>This sample construct used <code>cdk8splus22</code> library. The reason for this naming convention is because  each <code>cdk8s-plus</code> library is separately vended to target a specific Kubernetes version - the <code>22</code> at the end signifies that this dependency will work with Kubernetes <code>1.22</code>. You can use the library corresponding to your Kubernetes version and refer to the FAQs for more info.</p> <p>We use the MySQL password from <code>props</code> and use that to create the <code>Secret</code>.</p> <pre><code>    //...\n    password := props.MySQLPassword\n    mysqlSecret := cdk8splus22.NewSecret(wordpressConstruct, jsii.String(\"mysql-secret\"),\n        &amp;cdk8splus22.SecretProps{\n            Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(secretName)}}) \n    secretKey := \"password\"\n    mysqlSecret.AddStringData(jsii.String(secretKey), password)\n    //...\n</code></pre> <p>The container images for MySQL and Wordpress are referenced via their respective <code>Deployment</code>s:</p> <pre><code>//...\n    containerImage := props.MySQLImage\n\n    mysqlContainer := dep.AddContainer(&amp;cdk8splus22.ContainerProps{\n        Name:  jsii.String(\"mysql-container\"),\n        Image: containerImage,\n        Port:  jsii.Number(3306),\n    })\n//...\n\n    wordpressContainer := wordPressDeployment.AddContainer(&amp;cdk8splus22.ContainerProps{\n        Name:  jsii.String(\"wordpress-container\"),\n        Image: props.WordpressImage,\n        Port:  jsii.Number(80),\n    })\n</code></pre> <p>We also use the passed in storage as well - this is used to configure the <code>PersistentVolumeClaim</code> request.</p> <pre><code>...\n    mysqlPVC := cdk8splus22.NewPersistentVolumeClaim(wordpressConstruct, jsii.String(\"mysql-pvc\"), &amp;cdk8splus22.PersistentVolumeClaimProps{\n        AccessModes: &amp;[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE},\n        Storage:     cdk8s.Size_Gibibytes(props.MySQLStorage)})\n...\n\n    wordpressPVC := cdk8splus22.NewPersistentVolumeClaim(wordpressConstruct, jsii.String(\"wordpress-pvc\"), &amp;cdk8splus22.PersistentVolumeClaimProps{\n        AccessModes: &amp;[]cdk8splus22.PersistentVolumeAccessMode{cdk8splus22.PersistentVolumeAccessMode_READ_WRITE_ONCE},\n        Storage:     cdk8s.Size_Gibibytes(props.WordpressStorage)})\n</code></pre> <p>Finally, we call <code>NewWordpressStack</code> from another <code>cdk8s.Chart</code> and pass in the attributes we want to configure.</p> <pre><code>func NewMyChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {\n    var cprops cdk8s.ChartProps\n    if props != nil {\n        cprops = props.ChartProps\n    }\n    chart := cdk8s.NewChart(scope, jsii.String(id), &amp;cprops)\n\n    NewWordpressStack(chart, jsii.String(\"wordpress-stack\"), &amp;WordpressProps{\n        MySQLImage:       jsii.String(\"mysql\"),\n        MySQLPassword:    jsii.String(\"Password123\"),\n        MySQLStorage:     jsii.Number(3),\n        WordpressImage:   jsii.String(\"wordpress:4.8-apache\"),\n        WordpressStorage: jsii.Number(2)})\n\n    return chart\n}\n</code></pre>"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/#use-this-to-install-wordpress","title":"Use this to install Wordpress","text":"<p>To test it locally...</p> <p>... you can use minikube, kind, etc.</p> <pre><code># make sure cluster is running\nminikube start\n\ngit clone https://github.com/abhirockzz/cdk8s-for-go-developers\ncd part4-custom-construct\n</code></pre> <p>Create manifest and inspect all the resources (see <code>dist</code> directory):</p> <pre><code>cdk8s synth\n</code></pre> <p>To deploy them:</p> <pre><code>kubectl apply -f dist/\n\n# output (might differ in your case)\n\nsecret/mysql-pass created\ndeployment.apps/mysql-mysql-deployment-cdk8splus-c83762d9 created\npersistentvolumeclaim/mysql-mysql-pvc-c8799bba created\nservice/mysql-service created\ndeployment.apps/wordpress-wordpress-deployment-cdk8splus-c8252da7 created\nservice/wordpress-service created\npersistentvolumeclaim/wordpress-wordpress-pvc-c8334a29 created\n</code></pre> <p>Check the Kubernetes <code>Service</code> (called <code>wordpress-service</code>) which exposes the wordpress <code>Deployment</code>.</p> <pre><code>kubectl get svc wordpress-service\n</code></pre> <p>If you're using <code>minikube</code>, in a different terminal run (if not already running):</p> <pre><code>minikube tunnel\n</code></pre> <p>Use your browser to navigate to http://localhost:80. You should see the familiar Wordpress installation screen.</p> <p></p> <p>Go ahead, finish the installation and log into your Wordpress instance. Feel free to experiment with it. </p>"},{"location":"Part%204%3A%20Extend%20cdk8s%20with%20custom%20Constructs/#conclusion","title":"Conclusion","text":"<p><code>cdk8s</code> is a powerful tool itself but it also provides you the ability to extend and build other abstraction on top of it. You saw how to write a custom construct in <code>Go</code> and used it deploy Wordpress on Kubernetes. This can be further used as a foundation for other re-usable components.</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/","title":"Write your Kubernetes Infrastructure as Go code - Manage AWS services","text":"<p>Deploy DynamoDB and a client app using <code>cdk8s</code> along with AWS Controller for Kubernetes</p> <p>AWS Controllers for Kubernetes (also known as ACK) are built around the Kubernetes extension concepts of Custom Resource and Custom Resource Definitions. You can use <code>ACK</code> to define and use AWS services directly from Kubernetes. This helps you take advantage of managed AWS services for your Kubernetes applications without needing to define resources outside of the cluster.</p> <p>Say you need to use a AWS S3 Bucket in your application that's deployed to Kubernetes. Instead of using AWS console, AWS CLI, AWS CloudFormation etc., you can define the AWS <code>S3</code> Bucket in a YAML manifest file and deploy it using familiar tools such as <code>kubectl</code>. The end goal is to allow users (Software Engineers, DevOps engineers, operators etc.) to use the same interface (Kubernetes API in this case) to describe and manage AWS services along with native Kubernetes resources such as <code>Deployment</code>, <code>Service</code> etc.</p> <p>Here is a diagram from the ACK documentation, that provides a high level overview:</p> <p></p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#whats-covered-in-this-blog-post","title":"What's covered in this blog post?","text":"<p>ACK supports many AWS services, including Amazon DynamoDB. One of the topics that this blog post covers is how to use <code>ACK</code> on Amazon EKS for managing <code>DynamoDB</code>. But, just creating a <code>DynamoDB</code> table isn't going to be all that interesting! </p> <p>In addition to it, you will also work with and deploy a client application - this is a trimmed down version of the URL shortener app covered in a previous blog post. While the first half of the blog will involve manual steps to help you understand the mechanics and get started, in the second half, we will switch to <code>cdk8s</code> and achieve the same goals using nothing but Go code.</p> <p></p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#cdk8s-what-why-because-infrastructure-is-code","title":"cdk8s? what, why? Because, Infrastructure IS code","text":"<p>cdk8s (Cloud Development Kit for Kubernetes) is an open-source framework (part of CNCF) that allows you to define your Kubernetes applications using regular programming languages (instead of <code>yaml</code>). We will continue on the same path i.e. push <code>yaml</code> to the background and use the Go programming language to define the core infrastructure (that happens to be <code>DynamoDB</code> in this example, but could be so much more) as well as the application components (Kubernetes <code>Deployment</code>, <code>Service</code> etc.). </p> <p>This is made possible due to the following <code>cdk8s</code> features:</p> <ol> <li><code>cdk8s</code> support for Kubernetes Custom Resource definitions that lets us magically import CRD as APIs.</li> <li>cdk8s-plus library that helps reduce/eliminate a lot of boilerplate code while working with Kubernetes resources in our Go code (or any other language for that matter)</li> </ol> <p>Before you dive in, please ensure you complete the prerequisites in order to work through the tutorial.</p> <p>The code is available on GitHub</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#prerequisites","title":"Prerequisites","text":"<p>To follow along step-by-step, in addition to an AWS account, you will need to have AWS CLI, cdk8s CLI, kubectl, helm and the Go programming language installed.</p> <p>There are a variety of ways in which you can create an Amazon EKS cluster. I prefer using eksctl CLI because of the convenience it offers!</p> <p>Ok let's get started. The first thing we need to do is...</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#set-up-the-dynamodb-controller","title":"Set up the DynamoDB controller","text":"<p>Most of the below steps are adapted from the <code>ACK</code> documentation - Install an ACK Controller</p> <p>Install it using <code>Helm</code>:</p> <pre><code>export SERVICE=dynamodb\nexport RELEASE_VERSION=`curl -sL https://api.github.com/repos/aws-controllers-k8s/$SERVICE-controller/releases/latest | grep '\"tag_name\":' | cut -d'\"' -f4`\nexport ACK_SYSTEM_NAMESPACE=ack-system\n\n# you can change the region if required\nexport AWS_REGION=us-east-1\n\naws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws\n\nhelm install --create-namespace -n $ACK_SYSTEM_NAMESPACE ack-$SERVICE-controller \\\n  oci://public.ecr.aws/aws-controllers-k8s/$SERVICE-chart --version=$RELEASE_VERSION --set=aws.region=$AWS_REGION\n</code></pre> <p>To confirm, run:</p> <pre><code>kubectl get crd\n\n# output (multiple CRDs)\ntables.dynamodb.services.k8s.aws\nfieldexports.services.k8s.aws\nglobaltables.dynamodb.services.k8s.aws\n# etc....\n</code></pre> <p>Since the <code>DynamoDB</code> controller has to interact with AWS Services (make API calls), we need to configure IAM Roles for Service Accounts (also known as IRSA).</p> <p>Refer to Configure IAM Permissions for details</p> <p>IRSA configuration</p> <p>First, create an OIDC identity provider for your cluster.</p> <pre><code>export EKS_CLUSTER_NAME=&lt;name of your EKS cluster&gt;\nexport AWS_REGION=&lt;cluster region&gt;\neksctl utils associate-iam-oidc-provider --cluster $EKS_CLUSTER_NAME --region $AWS_REGION --approve\n</code></pre> <p>The goal is to create an IAM role and attach appropriate permissions via policies. We can then create a Kubernetes Service Account and attach the IAM role to it. Thus, the controller <code>Pod</code> will be able to make AWS API calls. Note that we are using providing all <code>DynamoDB</code> permissions to our control via the <code>arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess</code> policy.</p> <p>Thanks to <code>eksctl</code>, this can be done with a single line!</p> <pre><code>export SERVICE=dynamodb\nexport ACK_K8S_SERVICE_ACCOUNT_NAME=ack-$SERVICE-controller\n\n# recommend using the same name\nexport ACK_SYSTEM_NAMESPACE=ack-system\nexport EKS_CLUSTER_NAME=&lt;enter EKS cluster name&gt;\nexport POLICY_ARN=arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess\n\n# IAM role has a format - do not change it. you can't use any arbitrary name\nexport IAM_ROLE_NAME=ack-$SERVICE-controller-role\n\neksctl create iamserviceaccount \\\n    --name $ACK_K8S_SERVICE_ACCOUNT_NAME \\\n    --namespace $ACK_SYSTEM_NAMESPACE \\\n    --cluster $EKS_CLUSTER_NAME \\\n    --role-name $IAM_ROLE_NAME \\\n    --attach-policy-arn $POLICY_ARN \\\n    --approve \\\n    --override-existing-serviceaccounts\n</code></pre> <p>The policy is per https://github.com/aws-controllers-k8s/dynamodb-controller/blob/main/config/iam/recommended-policy-arn</p> <p>To confirm, you can check whether the IAM role was created and also introspect the Kubernetes service account</p> <pre><code>aws iam get-role --role-name=$IAM_ROLE_NAME --query Role.Arn --output text\n\nkubectl describe serviceaccount/$ACK_K8S_SERVICE_ACCOUNT_NAME -n $ACK_SYSTEM_NAMESPACE\n\n# you will see similar output\n\nName:                ack-dynamodb-controller\nNamespace:           ack-system\nLabels:              app.kubernetes.io/instance=ack-dynamodb-controller\n                     app.kubernetes.io/managed-by=eksctl\n                     app.kubernetes.io/name=dynamodb-chart\n                     app.kubernetes.io/version=v0.1.3\n                     helm.sh/chart=dynamodb-chart-v0.1.3\n                     k8s-app=dynamodb-chart\nAnnotations:         eks.amazonaws.com/role-arn: arn:aws:iam::&lt;your AWS account ID&gt;:role/ack-dynamodb-controller-role\n                     meta.helm.sh/release-name: ack-dynamodb-controller\n                     meta.helm.sh/release-namespace: ack-system\nImage pull secrets:  &lt;none&gt;\nMountable secrets:   ack-dynamodb-controller-token-bbzxv\nTokens:              ack-dynamodb-controller-token-bbzxv\nEvents:              &lt;none&gt;\n</code></pre> <p>For <code>IRSA</code> to take effect, you need to restart the ACK <code>Deployment</code>:</p> <pre><code># Note the deployment name for ACK service controller from following command\nkubectl get deployments -n $ACK_SYSTEM_NAMESPACE\n\nkubectl -n $ACK_SYSTEM_NAMESPACE rollout restart deployment ack-dynamodb-controller-dynamodb-chart\n</code></pre> <p>Confirm that the <code>Deployment</code> has restarted (currently <code>Running</code>) and the <code>IRSA</code> is properly configured:</p> <pre><code>kubectl get pods -n $ACK_SYSTEM_NAMESPACE\n\nkubectl describe pod -n $ACK_SYSTEM_NAMESPACE ack-dynamodb-controller-dynamodb-chart-7dc99456c6-6shrm | grep \"^\\s*AWS_\"\n# The output should contain following two lines:\n\nAWS_ROLE_ARN=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;\nAWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token\n</code></pre> <p>Now that we're done with the configuration ...</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#we-can-move-on-to-the-fun-parts","title":"We can move on to the fun parts!","text":"<p>Start by creating the DynamoDB table</p> <p>Here is what the manifest looks like:</p> <pre><code>apiVersion: dynamodb.services.k8s.aws/v1alpha1\nkind: Table\nmetadata:\n  name: dynamodb-urls-ack\nspec:\n  tableName: urls\n  attributeDefinitions:\n    - attributeName: shortcode\n      attributeType: S\n  billingMode: PAY_PER_REQUEST\n  keySchema:\n    - attributeName: email\n      keyType: HASH\n</code></pre> <p>Clone the project, change to the correct directory and apply the manifest:</p> <pre><code>git clone https://github.com/abhirockzz/dynamodb-ack-cdk8s\ncd dynamodb-ack-cdk8s\n\n# create table\nkubectl apply -f manual/dynamodb-ack.yaml\n</code></pre> <p>You can check the DynamoDB table in the AWS console, or use the AWS CLI (<code>aws dynamodb list-tables</code>) to confirm. Our table is ready, now we can deploy our URL shortener application.</p> <p>But, before that, we need to create a Docker image and push it to a private repository in Amazon Elastic Container Registry (ECR).</p> <p>Create private repository in Amazon ECR</p> <p>Login to ECR:</p> <pre><code>aws ecr get-login-password --region &lt;enter region&gt; | docker login --username AWS --password-stdin &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com\n</code></pre> <p>Create repository:</p> <pre><code>aws ecr create-repository \\\n    --repository-name dynamodb-app \\\n    --region &lt;enter AWS region&gt;\n</code></pre> <p>Build image and push to ECR</p> <pre><code># if you're on Mac M1\n#export DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t dynamodb-app .\n\ndocker tag dynamodb-app:latest &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com/dynamodb-app:latest\n\ndocker push &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com/dynamodb-app:latest\n</code></pre> <p>Just like the controller, our application also needs <code>IRSA</code> to be able to execute <code>GetItem</code> and <code>PutItem</code> API calls on <code>DynamoDB</code>. </p> <p>Let's create another IRSA for the application</p> <pre><code># you can change the policy name. make sure yo use the same name in subsequent commands\naws iam create-policy --policy-name dynamodb-irsa-policy --policy-document file://manual/policy.json\n\neksctl create iamserviceaccount --name eks-dynamodb-app-sa --namespace default --cluster &lt;enter EKS cluster name&gt; --attach-policy-arn arn:aws:iam::&lt;enter AWS account ID&gt;:policy/dynamodb-irsa-policy --approve\n\nkubectl describe serviceaccount/eks-dynamodb-app-sa\n\n# output\n\nName:                eks-dynamodb-app-sa\nNamespace:           default\nLabels:              app.kubernetes.io/managed-by=eksctl\nAnnotations:         eks.amazonaws.com/role-arn: arn:aws:iam::&lt;AWS account ID&gt;:role/eksctl-eks-cluster-addon-iamserviceaccount-d-Role1-2KTGZO1GJRN\nImage pull secrets:  &lt;none&gt;\nMountable secrets:   eks-dynamodb-app-sa-token-5fcvf\nTokens:              eks-dynamodb-app-sa-token-5fcvf\nEvents:              &lt;none&gt;\n</code></pre> <p>Finally, we can deploy our application!</p> <p>In the <code>manual/app.yaml</code> file, make sure you replace the following attributes as per your environment: - Service account name - the above example used <code>eks-dynamodb-app-sa</code> - Docker image - Container environment variables for AWS region (e.g. <code>us-east-1</code>) and table name (this will be <code>urls</code> since that's the name we used)</p> <pre><code>kubectl apply -f app.yaml\n\n# output\ndeployment.apps/dynamodb-app configured\nservice/dynamodb-app-service created\n</code></pre> <p>This will create a <code>Deployment</code> as well as <code>Service</code> to access the application.</p> <p>Since the Service type is <code>LoadBalancer</code>, an appropriate AWS Load Balancer will be provisioned to allow for external access.</p> <p>Check <code>Pod</code> and <code>Service</code>:</p> <pre><code>kubectl get pods\nkubectl get service/dynamodb-app-service\n\n# to get the load balancer IP\nAPP_URL=$(kubectl get service/dynamodb-app-service -o jsonpath=\"{.status.loadBalancer.ingress[0].hostname}\")\necho $APP_URL\n\n# output example\na0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com\n</code></pre> <p>You have deployed the application and know the endpoint over which it's publicly accessible. </p> <p>You can try out the URL shortener service</p> <pre><code>curl -i -X POST -d 'https://abhirockzz.github.io/' $APP_URL:9090/\n\n# output\nHTTP/1.1 200 OK\nDate: Thu, 21 Jul 2022 11:03:40 GMT\nContent-Length: 25\nContent-Type: text/plain; charset=utf-8\n\n{\"ShortCode\":\"ae1e31a6\"}\n</code></pre> <p>If you get a <code>Could not resolve host</code> error while accessing the LB URL, wait for a minute or so and re-try</p> <p>You should receive a JSON response with a short code. Enter the following in your browser <code>http://&lt;enter APP_URL&gt;:9090/&lt;shortcode&gt;</code> e.g. <code>http://a0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com:9090/ae1e31a6</code> - you will be re-directed to the original URL.</p> <p>You can also use <code>curl</code>:</p> <pre><code># example\ncurl -i http://a0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com:9090/ae1e31a6\n\n# output\nHTTP/1.1 302 Found\nLocation: https://abhirockzz.github.io/\nDate: Thu, 21 Jul 2022 11:07:58 GMT\nContent-Length: 0\n</code></pre> <p>Enough of YAML I guess! Like I promised earlier, the second half will demonstrate how to achieve the same using <code>cdk8s</code> and Go.</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#kubernetes-infrastructure-as-go-code-with-cdk8s","title":"Kubernetes infrastructure as Go code with cdk8s","text":"<p>Assuming you've already cloned the project (as per above instructions), change to a different directory:</p> <pre><code>cd dynamodb-cdk8s\n</code></pre> <p>This is a pre-created <code>cdk8s</code> project that you can use. The entire logic is present in main.go file. We will first try it out and confirm that it works the same way. After that we will dive into the nitty gritty of the code.</p> <p>Delete the previously created <code>DynamoDB</code> table and along with the <code>Deployment</code> (and <code>Service</code>) as well:</p> <pre><code># you can also delete the table directly from AWS console\naws dynamodb delete-table --table-name urls\n\n# this will delete Deployment and Service (as well as AWS Load Balancer)\nkubectl delete -f manual/app.yaml\n</code></pre> <p>Use <code>cdk8s synth</code> to generate the manifest for DynamoDB table and the application. We can then apply it using <code>kubectl</code></p> <p>See the difference? Earlier, we defined the <code>DynamoDB</code> table, <code>Deployment</code> (and <code>Service</code>) manifests manually. <code>cdk8s</code> does not remove YAML altogether, but it provides a way for us to leverage regular programming languages (<code>Go</code> in this case) to define the components of our solution.</p> <pre><code>export TABLE_NAME=urls\nexport SERVICE_ACCOUNT=eks-dynamodb-app-sa\nexport DOCKER_IMAGE=&lt;enter ECR repo that you created earlier&gt;\n\ncdk8s synth\n\nls -lrt dist/\n\n#output\n0000-dynamodb.k8s.yaml\n0001-deployment.k8s.yaml\n</code></pre> <p>You will see two different manifests being generated by <code>cdk8s</code> since we defined two separate <code>cdk8s.Chart</code>s in the code - more on this soon. </p> <p>We can deploy them one by one:</p> <pre><code>kubectl apply -f dist/0000-dynamodb.k8s.yaml\n\n#output\ntable.dynamodb.services.k8s.aws/dynamodb-dynamodb-ack-cdk8s-table-c88d874d created\nconfigmap/export-dynamodb-urls-info created\nfieldexport.services.k8s.aws/export-dynamodb-tablename created\nfieldexport.services.k8s.aws/export-dynamodb-region created\n</code></pre> <p>As always, you can check the <code>DynamoDB</code> table either in console or AWS CLI - <code>aws dynamodb describe-table --table-name urls</code>. Looking at the output, the <code>DynamoDB</code> table part seems familiar...</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#but-whats-fieldexportservicesk8saws","title":"But what's <code>fieldexport.services.k8s.aws</code>??","text":"<p>... And why do we need a <code>ConfigMap</code>? I will give you the gist here. </p> <p>In the previous iteration, we hard-coded the table name and region in <code>manual/app.yaml</code>. While this works for this sample app, it is not scalable and might not even work for a few resources in case the metadata (like name etc.) is randomly generated. That's why there is this concept of a <code>FieldExport</code> that can \"export any spec or status field from an ACK resource into a Kubernetes <code>ConfigMap</code> or <code>Secret</code>\"</p> <p>You can read up on the details in the ACK documentation along with some examples. What you will see here is how to define a <code>FieldExport</code> and <code>ConfigMap</code> along with the <code>Deployment</code> which needs to be configured to accept its environment variables from the <code>ConfigMap</code> - all this in code, using Go (more on this during code walk-through).</p> <p>Check the <code>FieldExport</code> and <code>ConfigMap</code>:</p> <pre><code>kubectl get fieldexport\n\n#output\nNAME                        AGE\nexport-dynamodb-region      19s\nexport-dynamodb-tablename   19s\n\nkubectl get configmap/export-dynamodb-urls-info -o yaml\n</code></pre> <p>We started out with a blank <code>ConfigMap</code> (as per <code>cdk8s</code> logic), but <code>ACK</code> magically populated it with the attributes from the <code>Table</code> custom resource.</p> <pre><code>apiVersion: v1\ndata:\n  default.export-dynamodb-region: us-east-1\n  default.export-dynamodb-tablename: urls\nimmutable: false\nkind: ConfigMap\n#....omitted\n</code></pre> <p>We can now use the second manifest - no surprises here. Just like in the previous iteration, all it contains is the application <code>Deployment</code> and the <code>Service</code>. Check <code>Pod</code> and <code>Service</code>:</p> <pre><code>kubectl apply -f dist/0001-deployment.k8s.yaml\n\n#output\ndeployment.apps/dynamodb-app created\nservice/dynamodb-app-service configured\n\nkubectl get pods\nkubectl get svc\n</code></pre> <p>The entire setup is ready, just like it was earlier and you can test it the same way. I will not repeat the steps here. Instead, I will move to something more interesting.</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#cdk8s-code-walk-through","title":"cdk8s code walk-through","text":"<p>The logic is divided into two <code>Chart</code>s. I will only focus on key sections of the code and rest will be ommitted for brevity.</p> <p>DynamoDB and configuration</p> <p>We start by defining the <code>DynamoDB</code> table (name it <code>urls</code>) as well as the <code>ConfigMap</code> (note that it does not have any data at this point):</p> <pre><code>func NewDynamoDBChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {\n    //...\n    table := ddbcrd.NewTable(chart, jsii.String(\"dynamodb-ack-cdk8s-table\"), &amp;ddbcrd.TableProps{\n        Spec: &amp;ddbcrd.TableSpec{\n            AttributeDefinitions: &amp;[]*ddbcrd.TableSpecAttributeDefinitions{\n                {AttributeName: jsii.String(primaryKeyName), AttributeType: jsii.String(\"S\")}},\n            BillingMode: jsii.String(billingMode),\n            TableName:   jsii.String(tableName),\n            KeySchema: &amp;[]*ddbcrd.TableSpecKeySchema{\n                {AttributeName: jsii.String(primaryKeyName),\n                    KeyType: jsii.String(hashKeyType)}}}})\n\n  //...\n  cfgMap = cdk8splus22.NewConfigMap(chart, jsii.String(\"config-map\"),\n        &amp;cdk8splus22.ConfigMapProps{\n            Metadata: &amp;cdk8s.ApiObjectMetadata{\n                Name: jsii.String(configMapName)}})\n</code></pre> <p>Then we move on to the <code>FieldExport</code>s - one each for the AWS region and the table name. As soon as these are created, the <code>ConfigMap</code> is populated with the required data as per <code>from</code> and <code>to</code> configuration in the <code>FieldExport</code>.</p> <pre><code>//...\n    fieldExportForTable = servicesk8saws.NewFieldExport(chart, jsii.String(\"fexp-table\"), &amp;servicesk8saws.FieldExportProps{\n        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(fieldExportNameForTable)},\n        Spec: &amp;servicesk8saws.FieldExportSpec{\n            From: &amp;servicesk8saws.FieldExportSpecFrom{Path: jsii.String(\".spec.tableName\"),\n                Resource: &amp;servicesk8saws.FieldExportSpecFromResource{\n                    Group: jsii.String(\"dynamodb.services.k8s.aws\"),\n                    Kind:  jsii.String(\"Table\"),\n                    Name:  table.Name()}},\n            To: &amp;servicesk8saws.FieldExportSpecTo{\n                Name: cfgMap.Name(),\n                Kind: servicesk8saws.FieldExportSpecToKind_CONFIGMAP}}})\n\n    fieldExportForRegion = servicesk8saws.NewFieldExport(chart, jsii.String(\"fexp-region\"), &amp;servicesk8saws.FieldExportProps{\n        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(fieldExportNameForRegion)},\n        Spec: &amp;servicesk8saws.FieldExportSpec{\n            From: &amp;servicesk8saws.FieldExportSpecFrom{\n                Path: jsii.String(\".status.ackResourceMetadata.region\"),\n                Resource: &amp;servicesk8saws.FieldExportSpecFromResource{\n                    Group: jsii.String(\"dynamodb.services.k8s.aws\"),\n                    Kind:  jsii.String(\"Table\"),\n                    Name:  table.Name()}},\n            To: &amp;servicesk8saws.FieldExportSpecTo{\n                Name: cfgMap.Name(),\n                Kind: servicesk8saws.FieldExportSpecToKind_CONFIGMAP}}})\n//...\n</code></pre> <p>The application chart</p> <p>The core of our application is the <code>Deployment</code> itself:</p> <pre><code>func NewDeploymentChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {\n  //...\n  dep := cdk8splus22.NewDeployment(chart, jsii.String(\"dynamodb-app-deployment\"), &amp;cdk8splus22.DeploymentProps{\n        Metadata: &amp;cdk8s.ApiObjectMetadata{\n            Name: jsii.String(\"dynamodb-app\")},\n        ServiceAccount: cdk8splus22.ServiceAccount_FromServiceAccountName(\n            chart,\n            jsii.String(\"aws-irsa\"),\n            jsii.String(serviceAccountName))})\n</code></pre> <p>The next important part is the container and it's configuration. We specify the ECR image repository along with the environment variables - they reference the <code>ConfigMap</code> we defined in the previous chart (everything is connected!):</p> <pre><code>//...\ncontainer := dep.AddContainer(\n        &amp;cdk8splus22.ContainerProps{\n            Name:  jsii.String(\"dynamodb-app-container\"),\n            Image: jsii.String(image),\n            Port:  jsii.Number(appPort)})\n\n    container.Env().AddVariable(jsii.String(\"TABLE_NAME\"), cdk8splus22.EnvValue_FromConfigMap(\n        cfgMap, jsii.String(\"default.\"+*fieldExportForTable.Name()),\n        &amp;cdk8splus22.EnvValueFromConfigMapOptions{Optional: jsii.Bool(false)}))\n\n    container.Env().AddVariable(jsii.String(\"AWS_REGION\"), cdk8splus22.EnvValue_FromConfigMap(\n        cfgMap, jsii.String(\"default.\"+*fieldExportForRegion.Name()),\n        &amp;cdk8splus22.EnvValueFromConfigMapOptions{Optional: jsii.Bool(false)}))\n</code></pre> <p>Finally, we define the <code>Service</code> (type <code>LoadBalancer</code>) which enables external application access and tie it all together in the <code>main</code> function:</p> <pre><code>//...\n    dep.ExposeViaService(\n        &amp;cdk8splus22.DeploymentExposeViaServiceOptions{\n            Name:        jsii.String(\"dynamodb-app-service\"),\n            ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,\n            Ports: &amp;[]*cdk8splus22.ServicePort{\n                {Protocol: cdk8splus22.Protocol_TCP,\n                    Port:       jsii.Number(lbPort),\n                    TargetPort: jsii.Number(appPort)}}})\n//...\n\nfunc main() {\n    app := cdk8s.NewApp(nil)\n\n    dynamodDB := NewDynamoDBChart(app, \"dynamodb\", nil)\n    deployment := NewDeploymentChart(app, \"deployment\", nil)\n\n    deployment.AddDependency(dynamodDB)\n\n    app.Synth()\n}\n</code></pre> <p>That's all I have for you in this blog!</p>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#dont-forget-to-delete-resources","title":"Don't forget to delete resources..","text":"<pre><code># delete DynamoDB table, Deployment, Service etc.\nkubectl delete -f dist/\n\n# to uninstall the ACK controller\nexport SERVICE=dynamodb\nhelm uninstall -n $ACK_SYSTEM_NAMESPACE ack-$SERVICE-controller\n\n# delete the EKS cluster. if created via eksctl:\neksctl delete cluster --name &lt;enter name of eks cluster&gt;\n</code></pre>"},{"location":"Part%205%3A%20Write%20your%20Kubernetes%20Infrastructure%20as%20Go%20code%20-%20Manage%20AWS%20services/#wrap-up","title":"Wrap up..","text":"<p>AWS Controllers for Kubernetes help bridge the gap between traditional Kubernetes resources and AWS services by allowing you to manage both from a single control plane. In this blog you saw how to do this in the context of <code>DynamoDB</code> and a URL shortener application (deployed to Kubernetes). I encourage you to try out other AWS services that ACK supports - here is a complete list.</p> <p>The approach presented here will work well if just want to use <code>cdk8s</code>. However, depending on your requirements, there is another way this can done by bringing in AWS CDK into the picture. I want to pause right here since this is something I might cover in a future blog post. </p> <p>Until then, Happy Building!</p>"},{"location":"Part%206%3A%20Coming%20soon/","title":"Write your Kubernetes Infrastructure as Go code - Combine cdk8s with AWS CDK","text":"<p>In an earlier blog post with AWS Controllers for Kubernetes (also known as ACK), thanks to the fact that you can import existing Kubernetes Custom Resource Definitions using <code>cdk8s</code>! This made is possible to deploy <code>DynamoDB</code> along with a client application, from  using <code>cdk8s</code> and Kubernetes.</p> <p>But, what if you continue using AWS CDK for AWS infrastructure and harness the power <code>cdk8s</code> (and <code>cdk8s-plus</code>!) to define Kubernetes resources using regular code? Thanks to the native integration between the AWS EKS module and cdk8s, you can have the best of both worlds! </p> <p>The goal of this blog post is to demonstrate that with a few examples. We will start off with a simple (nginx based) example before moving on to a full-fledged application stack (including <code>DynamoDB</code> etc.). Both will be using the Go programming language which is well supported in AWS CDK as well as cdk8s.</p> <p>All the code discussed in this blog is available in this GitHub repo</p>"},{"location":"Part%206%3A%20Coming%20soon/#prerequisites","title":"Prerequisites","text":"<p>To follow along step-by-step, in addition to an AWS account, you will need following CLIs - AWS CLI, cdk8s CLI and kubectl. Also, dont' forget to install AWS CDK, the Go programming language (v1.16 or above) as well as Docker, if you don't have them already.</p>"},{"location":"Part%206%3A%20Coming%20soon/#keeping-it-simple-with-nginx-on-eks","title":"Keeping it simple with Nginx on EKS","text":"<p>As with most things in life, there are two ways - the easy way or the hard way ;) You will see both of them! Let's try things out first, see them working and then look at the code.</p> <p>To start off, clone the repo and change to the right directory:</p> <pre><code>git clone https://github.com/abhirockzz/cdk8s-for-go-developers\ncd cdk8s-for-go-developers/part6-cdk-eks-cdk8s/cdk-cdk8s-nginx-eks\n</code></pre> <p>To setup everything, all you need is a single command:</p> <pre><code>cdk deploy\n</code></pre> <p>you can also use <code>cdk synth</code> to generate and inspect the Cloud Formation template first</p> <p>You will be prompted to confirm. Once you do that, the process will kick off - it will take some time since lots of AWS resources will be created, including VPC, EKS cluster etc.</p> <p>Feel free to check the AWS Cloud Formation console to track the progress.</p> <p>Once the process is complete, you need to connect to the EKS cluster using <code>kubectl</code>. The command required for this will be available as a result of the <code>cdk deploy</code> process (in the terminal) or you can refer to the Outputs section of the AWS Cloud Formation stack.</p> <p></p> <p>Once you've configured <code>kubectl</code> to point to your EKS cluster, you can check the Nginx <code>Deployment</code> and <code>Service</code>.</p> <pre><code>kubectl get deployment\n\n# output\n\nNAME                          READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-deployment-cdk8s        1/1     1            1           1m\nnginx-deployment-cdk          1/1     1            1           1m\n</code></pre> <p>You will see that two <code>Deployment</code>s have been created - more on this soon. Similiarly, if you check the <code>Service</code> (<code>kubectl get svc</code>), you should see two of them - <code>nginx-service-cdk</code> and <code>nginx-service-cdk8s</code>.</p> <p>To access Nginx, pick the <code>EXTERNAL-IP</code> of any of the two <code>Service</code>s. For example:</p> <pre><code>APP_URL=$(kubectl get service/nginx-service-cdk -o jsonpath=\"{.status.loadBalancer.ingress[0].hostname}\")\n\necho $APP_URL\n\n# to access nginx (notice we are using port 9090)\ncurl -i http://$APP_URL:9090\n</code></pre> <p>If you get a <code>Could not resolve host</code> error while accessing the LB URL, wait for a minute or so and re-try</p>"},{"location":"Part%206%3A%20Coming%20soon/#behind-the-scenes","title":"Behind the scenes","text":"<p>Let's look at the code now - this will clarify why we have two Nginx <code>Deployment</code>s.</p> <p>Thanks to AWS CDK, VPC creation is a one liner with awsec2.NewVpc function and creating an EKS cluster isn't too hard either!</p> <pre><code>func NewNginxOnEKSStack(scope constructs.Construct, id string, props *CdkStackProps) awscdk.Stack {\n  //...\n  vpc := awsec2.NewVpc(stack, jsii.String(\"demo-vpc\"), nil)\n\n    eksSecurityGroup := awsec2.NewSecurityGroup(stack, jsii.String(\"eks-demo-sg\"),\n        &amp;awsec2.SecurityGroupProps{\n            Vpc:               vpc,\n            SecurityGroupName: jsii.String(\"eks-demo-sg\"),\n            AllowAllOutbound:  jsii.Bool(true)})\n\n    eksCluster := awseks.NewCluster(stack, jsii.String(\"demo-eks\"),\n        &amp;awseks.ClusterProps{\n            ClusterName:   jsii.String(\"demo-eks-cluster\"),\n            Version:       awseks.KubernetesVersion_V1_21(),\n            Vpc:           vpc,\n            SecurityGroup: eksSecurityGroup,\n            VpcSubnets: &amp;[]*awsec2.SubnetSelection{\n                {Subnets: vpc.PrivateSubnets()}},\n            DefaultCapacity:         jsii.Number(2),\n            DefaultCapacityInstance: awsec2.InstanceType_Of(awsec2.InstanceClass_BURSTABLE3, awsec2.InstanceSize_SMALL), DefaultCapacityType: awseks.DefaultCapacityType_NODEGROUP,\n            OutputConfigCommand: jsii.Bool(true),\n            EndpointAccess:      awseks.EndpointAccess_PUBLIC()})\n//...\n</code></pre>"},{"location":"Part%206%3A%20Coming%20soon/#nginx-on-kubernetes-the-hard-way","title":"Nginx on Kubernetes, the hard way!","text":"<p>Now we look at two different ways of creating Nginx, starting with the \"hard\" way. In this case, we use AWS CDK (not <code>cdk8s</code>) to define the <code>Deployment</code> and <code>Service</code> resources.</p> <pre><code>func deployNginxUsingCDK(eksCluster awseks.Cluster) {\n\n    appLabel := map[string]*string{\n        \"app\": jsii.String(\"nginx-eks-cdk\"),\n    }\n\n    deployment := map[string]interface{}{\n        \"apiVersion\": jsii.String(\"apps/v1\"),\n        \"kind\":       jsii.String(\"Deployment\"),\n        \"metadata\": map[string]*string{\n            \"name\": jsii.String(\"nginx-deployment-cdk\"),\n        },\n        \"spec\": map[string]interface{}{\n            \"replicas\": jsii.Number(1),\n            \"selector\": map[string]map[string]*string{\n                \"matchLabels\": appLabel,\n            },\n            \"template\": map[string]interface{}{\n                \"metadata\": map[string]map[string]*string{\n                    \"labels\": appLabel,\n                },\n                \"spec\": map[string][]map[string]interface{}{\n                    \"containers\": {\n                        {\n                            \"name\":  jsii.String(\"nginx\"),\n                            \"image\": jsii.String(\"nginx\"),\n                            \"ports\": []map[string]*float64{\n                                {\n                                    \"containerPort\": jsii.Number(80),\n                                },\n                            },\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    service := map[string]interface{}{\n        \"apiVersion\": jsii.String(\"v1\"),\n        \"kind\":       jsii.String(\"Service\"),\n        \"metadata\": map[string]*string{\n            \"name\": jsii.String(\"nginx-service-cdk\"),\n        },\n        \"spec\": map[string]interface{}{\n            \"type\": jsii.String(\"LoadBalancer\"),\n            \"ports\": []map[string]*float64{\n                {\n                    \"port\":       jsii.Number(9090),\n                    \"targetPort\": jsii.Number(80),\n                },\n            },\n            \"selector\": appLabel,\n        },\n    }\n\n    eksCluster.AddManifest(jsii.String(\"app-deployment\"), &amp;service, &amp;deployment)\n}\n</code></pre> <p>Finally, to create this in EKS we invoke AddManifest (think of its like the programmatic equivalent of <code>kubectl apply</code>). This works, but there are a few gaps in this approach:</p> <ul> <li>We are not able to reap the benefits of Go which is a strongly typed language. That's because the API is loosely typed, thanks to <code>map[string]interface{}</code> everywhere. This makes it very error prone (I made a few mistakes too!)</li> <li>The verbosity is apparent as well. It seems as if we are writing <code>YAML</code> in <code>Go</code> - not too much of an improvement!</li> </ul>"},{"location":"Part%206%3A%20Coming%20soon/#is-there-a-better-way","title":"Is there a better way..?","text":"<p>Let's look at the second function <code>deployNginxUsingCDK8s</code> - by the name its obvious that we used <code>cdk8s</code>, not just CDK)</p> <pre><code>func deployNginxUsingCDK8s(eksCluster awseks.Cluster) {\n\n    app := cdk8s.NewApp(nil)\n    eksCluster.AddCdk8sChart(jsii.String(\"nginx-eks-chart\"), NewNginxChart(app, \"nginx-cdk8s\", nil), nil)\n}\n</code></pre> <p>This looks \"too easy\" to to be true! But it's made possible due to the inter-operability between CDK and <code>cdk8s</code>. What this implies is that, you can use define Kubernetes resources using <code>cdk8s</code> <code>Chart</code>s and apply them to an EKS cluster created with CDK (this makes it sort of a hybrind system). </p> <p>The hero of our story is AddCdk8sChart function, which accepts a constructs.Construct (remember, everything is a construct!). In this case, the <code>Construct</code> happens to be a cdk8s.Chart thats returned by <code>NewNginxChart</code> function - so lets take a look at that.</p> <pre><code>func NewNginxChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {\n  //....\n\n    dep := cdk8splus22.NewDeployment(chart, jsii.String(\"nginx-deployment\"),\n        &amp;cdk8splus22.DeploymentProps{\n            Metadata: &amp;cdk8s.ApiObjectMetadata{\n                Name: jsii.String(\"nginx-deployment-cdk8s\")}})\n\n    dep.AddContainer(&amp;cdk8splus22.ContainerProps{\n        Name:  jsii.String(\"nginx-container\"),\n        Image: jsii.String(\"nginx\"),\n        Port:  jsii.Number(80)})\n\n    dep.ExposeViaService(&amp;cdk8splus22.DeploymentExposeViaServiceOptions{\n        Name:        jsii.String(\"nginx-service-cdk8s\"),\n        ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,\n        Ports: &amp;[]*cdk8splus22.ServicePort{{\n            Port:       jsii.Number(9090),\n            TargetPort: jsii.Number(80)}}})\n\n    return chart\n}\n</code></pre> <p>If you have worked with <code>cdk8s</code> (and Go) or read some of my previous blogs on this topic, this should look familiar - a strongly-typed, compact and expressive API! I don't even need to walk you through this since its so readable - we use <code>cdk8s-plus</code> to create a Nginx <code>Deployment</code>, add the container info and finally expose it via a <code>Service</code> so that we can access the Nginx from outside of EKS. </p> <p>This was a simple enough example to help bring out difference between the two approaches. The next scenario is different - in addition to the EKS cluster it has DynamoDB along with a URL shortener application that will be deployed to EKS.</p>"},{"location":"Part%206%3A%20Coming%20soon/#end-to-end-example-dynamodb-along-with-an-application-on-eks","title":"End to end example: DynamoDB along with an application on EKS","text":"<p>Instead of creating a new EKS cluster from scratch, we will re-use the existing cluster created as a result of the previous example - this is a good opportunity to take a look at how you can reference an existing EKS cluster in your CDK code. As expected, we need to create <code>DynamoDB</code> table as well. </p> <p>Just like in the previous example, let's try out the solution first. Change into the right directory first:</p> <pre><code>cd part6-cdk-eks-cdk8s/cdk-cdk8s-dynamodb-app-eks\n</code></pre> <p>Since the URL shortener application has to make API calls to <code>DynamoDB</code>, we need to configure IAM Roles for Service Accounts (also known as IRSA).</p> <p>Refer to https://docs.aws.amazon.com/eks/latest/userguide/create-service-account-iam-policy-and-role.html</p> <p>Define IAM roles for the application</p> <p>Start by creating a Kubernetes Service Account:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: eks-dynamodb-app-sa\nEOF\n</code></pre> <p>To confirm - <code>kubectl get serviceaccount/eks-dynamodb-app-sa -o yaml</code></p> <p>Set your AWS Account ID and OIDC Identity provider as environment variables:</p> <pre><code>ACCOUNT_ID=$(aws sts get-caller-identity --query \"Account\" --output text)\n\nexport EKS_CLUSTER_NAME=&lt;enter cluster name&gt;\nexport AWS_REGION=&lt;enter region e.g. us-east-1&gt;\n\nOIDC_PROVIDER=$(aws eks describe-cluster --name $EKS_CLUSTER_NAME --query \"cluster.identity.oidc.issuer\" --output text | sed -e \"s/^https:\\/\\///\")\n</code></pre> <p>Create a JSON file with Trusted Entities for the role:</p> <pre><code>read -r -d '' TRUST_RELATIONSHIP &lt;&lt;EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::${ACCOUNT_ID}:oidc-provider/${OIDC_PROVIDER}\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"${OIDC_PROVIDER}:aud\": \"sts.amazonaws.com\",\n          \"${OIDC_PROVIDER}:sub\": \"system:serviceaccount:default:eks-dynamodb-app-sa\"\n        }\n      }\n    }\n  ]\n}\nEOF\necho \"${TRUST_RELATIONSHIP}\" &gt; trust.json\n</code></pre> <p>Check - <code>cat trust.json</code></p> <p>Now, create the IAM role:</p> <pre><code>export ROLE_NAME=dynamodb-app-irsa\n\naws iam create-role --role-name $ROLE_NAME --assume-role-policy-document file://trust.json --description \"IRSA for DynamoDB app on EKS\"\n</code></pre> <p>We will need to create and attach policy to role since we only want to allow <code>PutItem</code> and <code>GetItem</code> operations from our application. Here is the policy JSON file:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"PutandGet\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"dynamodb:PutItem\",\n                \"dynamodb:GetItem\"\n            ],\n            \"Resource\": \"arn:aws:dynamodb:*:*:table/urls\"\n        }\n    ]\n}\n</code></pre> <p>Create and attach the policy to the role we just created:</p> <pre><code>aws iam create-policy --policy-name dynamodb-irsa-policy --policy-document file://policy.json\n\naws iam attach-role-policy --role-name $ROLE_NAME --policy-arn=arn:aws:iam::&lt;enter AWS account ID&gt;:policy/dynamodb-irsa-policy\n</code></pre> <p>Finally, we need to associate the IAM role and Service Account:</p> <pre><code>kubectl annotate serviceaccount -n default eks-dynamodb-app-sa eks.amazonaws.com/role-arn=arn:aws:iam::&lt;enter AWS account ID&gt;:role/dynamodb-app-irsa\n</code></pre> <p>Get the EKS <code>kubectl</code> role ARN</p> <p>To reference existing EKS cluster in AWS CDK, you need EKS cluster name and <code>kubectl</code> role ARN.</p> <p>You can find the role ARN in the Outputs section of the AWS Cloud Formation stack.</p> <p></p> <p>We are ready to deploy the application using CDK. Set the required environment variables followed by <code>cdk deploy</code>:</p> <p>you can also use <code>cdk synth</code> to generate and inspect the Cloud Formation template first</p> <pre><code>export EKS_CLUSTER_NAME=&lt;enter name of EKS cluster&gt;\nexport KUBECTL_ROLE_ARN=&lt;enter kubectl role ARN&gt;\nexport SERVICE_ACCOUNT_NAME=eks-dynamodb-app-sa\nexport APP_PORT=8080\nexport AWS_REGION=&lt;enter region e.g. us-east-1&gt;\n\ncdk deploy\n</code></pre> <p>CDK (and <code>cdk8s</code>) will do all the heavy lifting (we will look at the code very soon):</p> <ul> <li>New DynamoDB table will be created</li> <li>The docker image for our application will be built and pushed to ECR</li> <li>Kubernetes resources for the URL shortener application will be deployed to the existing EKS cluster</li> </ul> <p>Once the stack creation is complete, check the Kubernetes <code>Deployment</code> and <code>Service</code>:</p> <pre><code>kubectl get deployment/dynamodb-app\nkubectl get pods\nkubectl get service/dynamodb-app-service\n</code></pre> <p>Testing the URL shortener service is easy. But I will not repeat it here since its already covered in [this blog](https://dev.to/abhirockzz/write-your-kubernetes-infrastructure-as-go-code-manage-aws-services-3pgi. All you need is the load balancer URL to access the service and use yout browser or <code>curl</code> to save and access URLs.</p> <p>Back to exploring Go code again</p> <p>Within the stack, we define the <code>DynamoDB</code> table (using awsdynamodb.NewTable) along with the docker image for our application (with awsecrassets.NewDockerImageAsset)</p> <pre><code>func NewDynamoDBAppStack(scope constructs.Construct, id string, props *CdkStackProps) awscdk.Stack {\n  //...\n    table := awsdynamodb.NewTable(stack, jsii.String(\"dynamodb-table\"),\n        &amp;awsdynamodb.TableProps{\n            TableName: jsii.String(tableName),\n            PartitionKey: &amp;awsdynamodb.Attribute{\n                Name: jsii.String(dynamoDBPartitionKey),\n                Type: awsdynamodb.AttributeType_STRING,\n            },\n            BillingMode:   awsdynamodb.BillingMode_PAY_PER_REQUEST,\n            RemovalPolicy: awscdk.RemovalPolicy_DESTROY,\n        })\n\n    appDockerImage := awsecrassets.NewDockerImageAsset(stack, jsii.String(\"app-image\"),\n        &amp;awsecrassets.DockerImageAssetProps{\n            Directory: jsii.String(appDirectory)})\n  //...\n</code></pre> <p>Then comes the interesting part where we get the reference to our exsiting EKS cluster and use <code>AddCdk8sChart</code> (just like before) to deploy the application to EKS.</p> <pre><code>//...\n  eksCluster := awseks.Cluster_FromClusterAttributes(stack, jsii.String(\"existing cluster\"),\n        &amp;awseks.ClusterAttributes{\n            ClusterName:    jsii.String(eksClusterName),\n            KubectlRoleArn: jsii.String(kubectlRoleARN)})\n\n    app := cdk8s.NewApp(nil)\n    appProps := NewAppChartProps(appDockerImage.ImageUri(), table.TableName())\n\n    eksCluster.AddCdk8sChart(jsii.String(\"dynamodbapp-chart\"), NewDynamoDBAppChart(app, \"dynamodb-cdk8s\", &amp;appProps), nil)\n</code></pre> <p>The NewDynamoDBAppChart function defines the <code>Deployment</code> and <code>Service</code>. Unlike the earlier Nginx example which had static values, this application takes in dynamic values - specifically the <code>DynamoDB</code> table name (which is used as the container environment variable <code>TABLE_NAME</code>). Also notice the fact that we explicitly add the the name of the Kubernetes service account (for IRSA) that we had created in the previous step.</p> <pre><code>func NewDynamoDBAppChart(scope constructs.Construct, id string, props *AppChartProps) cdk8s.Chart {\n  //...\n    dep := cdk8splus22.NewDeployment(chart, jsii.String(\"dynamodb-app-deployment\"), &amp;cdk8splus22.DeploymentProps{\n        Metadata: &amp;cdk8s.ApiObjectMetadata{\n            Name: jsii.String(\"dynamodb-app\")},\n        ServiceAccount: cdk8splus22.ServiceAccount_FromServiceAccountName(\n            chart,\n            jsii.String(\"aws-irsa\"),\n            jsii.String(props.serviceAccountName))})\n\n    container := dep.AddContainer(//.. omitted for brevity)\n\n    container.Env().AddVariable(jsii.String(\"TABLE_NAME\"), cdk8splus22.EnvValue_FromValue(props.tableName))\n    container.Env().AddVariable(jsii.String(\"AWS_REGION\"), cdk8splus22.EnvValue_FromValue(&amp;props.region))\n\n    dep.ExposeViaService(//.. omitted for brevity)\n    return chart\n}\n</code></pre>"},{"location":"Part%206%3A%20Coming%20soon/#wrap-up","title":"Wrap up","text":"<p>That's all for this blog! We started off with a simple example to showcase the integration between AWS CDK and <code>cdk8s</code> and how easy it makes things (compared to just using CDK to deploy apps to EKS). Then, we moved on to explore a full fledged scenario where you deployed the infrastructure (<code>DynamoDB</code> etc.) along with the client application on EKS.</p> <p>Happy Building!</p>"}]}